// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package servicesmocks

import (
	"context"

	"github.com/a-novel/service-narrative-engine/internal/dao"
	mock "github.com/stretchr/testify/mock"
)

// NewMockModuleCreateRepository creates a new instance of MockModuleCreateRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockModuleCreateRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockModuleCreateRepository {
	mock := &MockModuleCreateRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockModuleCreateRepository is an autogenerated mock type for the ModuleCreateRepository type
type MockModuleCreateRepository struct {
	mock.Mock
}

type MockModuleCreateRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockModuleCreateRepository) EXPECT() *MockModuleCreateRepository_Expecter {
	return &MockModuleCreateRepository_Expecter{mock: &_m.Mock}
}

// Exec provides a mock function for the type MockModuleCreateRepository
func (_mock *MockModuleCreateRepository) Exec(ctx context.Context, request *dao.ModuleInsertRequest) (*dao.Module, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for Exec")
	}

	var r0 *dao.Module
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *dao.ModuleInsertRequest) (*dao.Module, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *dao.ModuleInsertRequest) *dao.Module); ok {
		r0 = returnFunc(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dao.Module)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *dao.ModuleInsertRequest) error); ok {
		r1 = returnFunc(ctx, request)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockModuleCreateRepository_Exec_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exec'
type MockModuleCreateRepository_Exec_Call struct {
	*mock.Call
}

// Exec is a helper method to define mock.On call
//   - ctx context.Context
//   - request *dao.ModuleInsertRequest
func (_e *MockModuleCreateRepository_Expecter) Exec(ctx interface{}, request interface{}) *MockModuleCreateRepository_Exec_Call {
	return &MockModuleCreateRepository_Exec_Call{Call: _e.mock.On("Exec", ctx, request)}
}

func (_c *MockModuleCreateRepository_Exec_Call) Run(run func(ctx context.Context, request *dao.ModuleInsertRequest)) *MockModuleCreateRepository_Exec_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *dao.ModuleInsertRequest
		if args[1] != nil {
			arg1 = args[1].(*dao.ModuleInsertRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockModuleCreateRepository_Exec_Call) Return(module *dao.Module, err error) *MockModuleCreateRepository_Exec_Call {
	_c.Call.Return(module, err)
	return _c
}

func (_c *MockModuleCreateRepository_Exec_Call) RunAndReturn(run func(ctx context.Context, request *dao.ModuleInsertRequest) (*dao.Module, error)) *MockModuleCreateRepository_Exec_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockModuleCreateRepositoryDelete creates a new instance of MockModuleCreateRepositoryDelete. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockModuleCreateRepositoryDelete(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockModuleCreateRepositoryDelete {
	mock := &MockModuleCreateRepositoryDelete{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockModuleCreateRepositoryDelete is an autogenerated mock type for the ModuleCreateRepositoryDelete type
type MockModuleCreateRepositoryDelete struct {
	mock.Mock
}

type MockModuleCreateRepositoryDelete_Expecter struct {
	mock *mock.Mock
}

func (_m *MockModuleCreateRepositoryDelete) EXPECT() *MockModuleCreateRepositoryDelete_Expecter {
	return &MockModuleCreateRepositoryDelete_Expecter{mock: &_m.Mock}
}

// Exec provides a mock function for the type MockModuleCreateRepositoryDelete
func (_mock *MockModuleCreateRepositoryDelete) Exec(ctx context.Context, request *dao.ModuleDeleteRequest) (*dao.Module, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for Exec")
	}

	var r0 *dao.Module
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *dao.ModuleDeleteRequest) (*dao.Module, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *dao.ModuleDeleteRequest) *dao.Module); ok {
		r0 = returnFunc(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dao.Module)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *dao.ModuleDeleteRequest) error); ok {
		r1 = returnFunc(ctx, request)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockModuleCreateRepositoryDelete_Exec_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exec'
type MockModuleCreateRepositoryDelete_Exec_Call struct {
	*mock.Call
}

// Exec is a helper method to define mock.On call
//   - ctx context.Context
//   - request *dao.ModuleDeleteRequest
func (_e *MockModuleCreateRepositoryDelete_Expecter) Exec(ctx interface{}, request interface{}) *MockModuleCreateRepositoryDelete_Exec_Call {
	return &MockModuleCreateRepositoryDelete_Exec_Call{Call: _e.mock.On("Exec", ctx, request)}
}

func (_c *MockModuleCreateRepositoryDelete_Exec_Call) Run(run func(ctx context.Context, request *dao.ModuleDeleteRequest)) *MockModuleCreateRepositoryDelete_Exec_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *dao.ModuleDeleteRequest
		if args[1] != nil {
			arg1 = args[1].(*dao.ModuleDeleteRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockModuleCreateRepositoryDelete_Exec_Call) Return(module *dao.Module, err error) *MockModuleCreateRepositoryDelete_Exec_Call {
	_c.Call.Return(module, err)
	return _c
}

func (_c *MockModuleCreateRepositoryDelete_Exec_Call) RunAndReturn(run func(ctx context.Context, request *dao.ModuleDeleteRequest) (*dao.Module, error)) *MockModuleCreateRepositoryDelete_Exec_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockModuleListVersionsRepository creates a new instance of MockModuleListVersionsRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockModuleListVersionsRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockModuleListVersionsRepository {
	mock := &MockModuleListVersionsRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockModuleListVersionsRepository is an autogenerated mock type for the ModuleListVersionsRepository type
type MockModuleListVersionsRepository struct {
	mock.Mock
}

type MockModuleListVersionsRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockModuleListVersionsRepository) EXPECT() *MockModuleListVersionsRepository_Expecter {
	return &MockModuleListVersionsRepository_Expecter{mock: &_m.Mock}
}

// Exec provides a mock function for the type MockModuleListVersionsRepository
func (_mock *MockModuleListVersionsRepository) Exec(ctx context.Context, request *dao.ModuleListVersionsRequest) ([]*dao.ModuleVersion, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for Exec")
	}

	var r0 []*dao.ModuleVersion
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *dao.ModuleListVersionsRequest) ([]*dao.ModuleVersion, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *dao.ModuleListVersionsRequest) []*dao.ModuleVersion); ok {
		r0 = returnFunc(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*dao.ModuleVersion)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *dao.ModuleListVersionsRequest) error); ok {
		r1 = returnFunc(ctx, request)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockModuleListVersionsRepository_Exec_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exec'
type MockModuleListVersionsRepository_Exec_Call struct {
	*mock.Call
}

// Exec is a helper method to define mock.On call
//   - ctx context.Context
//   - request *dao.ModuleListVersionsRequest
func (_e *MockModuleListVersionsRepository_Expecter) Exec(ctx interface{}, request interface{}) *MockModuleListVersionsRepository_Exec_Call {
	return &MockModuleListVersionsRepository_Exec_Call{Call: _e.mock.On("Exec", ctx, request)}
}

func (_c *MockModuleListVersionsRepository_Exec_Call) Run(run func(ctx context.Context, request *dao.ModuleListVersionsRequest)) *MockModuleListVersionsRepository_Exec_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *dao.ModuleListVersionsRequest
		if args[1] != nil {
			arg1 = args[1].(*dao.ModuleListVersionsRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockModuleListVersionsRepository_Exec_Call) Return(moduleVersions []*dao.ModuleVersion, err error) *MockModuleListVersionsRepository_Exec_Call {
	_c.Call.Return(moduleVersions, err)
	return _c
}

func (_c *MockModuleListVersionsRepository_Exec_Call) RunAndReturn(run func(ctx context.Context, request *dao.ModuleListVersionsRequest) ([]*dao.ModuleVersion, error)) *MockModuleListVersionsRepository_Exec_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockModuleLoadSystemRepository creates a new instance of MockModuleLoadSystemRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockModuleLoadSystemRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockModuleLoadSystemRepository {
	mock := &MockModuleLoadSystemRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockModuleLoadSystemRepository is an autogenerated mock type for the ModuleLoadSystemRepository type
type MockModuleLoadSystemRepository struct {
	mock.Mock
}

type MockModuleLoadSystemRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockModuleLoadSystemRepository) EXPECT() *MockModuleLoadSystemRepository_Expecter {
	return &MockModuleLoadSystemRepository_Expecter{mock: &_m.Mock}
}

// Exec provides a mock function for the type MockModuleLoadSystemRepository
func (_mock *MockModuleLoadSystemRepository) Exec(ctx context.Context, request *dao.ModuleInsertRequest) (*dao.Module, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for Exec")
	}

	var r0 *dao.Module
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *dao.ModuleInsertRequest) (*dao.Module, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *dao.ModuleInsertRequest) *dao.Module); ok {
		r0 = returnFunc(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dao.Module)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *dao.ModuleInsertRequest) error); ok {
		r1 = returnFunc(ctx, request)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockModuleLoadSystemRepository_Exec_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exec'
type MockModuleLoadSystemRepository_Exec_Call struct {
	*mock.Call
}

// Exec is a helper method to define mock.On call
//   - ctx context.Context
//   - request *dao.ModuleInsertRequest
func (_e *MockModuleLoadSystemRepository_Expecter) Exec(ctx interface{}, request interface{}) *MockModuleLoadSystemRepository_Exec_Call {
	return &MockModuleLoadSystemRepository_Exec_Call{Call: _e.mock.On("Exec", ctx, request)}
}

func (_c *MockModuleLoadSystemRepository_Exec_Call) Run(run func(ctx context.Context, request *dao.ModuleInsertRequest)) *MockModuleLoadSystemRepository_Exec_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *dao.ModuleInsertRequest
		if args[1] != nil {
			arg1 = args[1].(*dao.ModuleInsertRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockModuleLoadSystemRepository_Exec_Call) Return(module *dao.Module, err error) *MockModuleLoadSystemRepository_Exec_Call {
	_c.Call.Return(module, err)
	return _c
}

func (_c *MockModuleLoadSystemRepository_Exec_Call) RunAndReturn(run func(ctx context.Context, request *dao.ModuleInsertRequest) (*dao.Module, error)) *MockModuleLoadSystemRepository_Exec_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockModuleLoadSystemRepositoryDelete creates a new instance of MockModuleLoadSystemRepositoryDelete. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockModuleLoadSystemRepositoryDelete(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockModuleLoadSystemRepositoryDelete {
	mock := &MockModuleLoadSystemRepositoryDelete{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockModuleLoadSystemRepositoryDelete is an autogenerated mock type for the ModuleLoadSystemRepositoryDelete type
type MockModuleLoadSystemRepositoryDelete struct {
	mock.Mock
}

type MockModuleLoadSystemRepositoryDelete_Expecter struct {
	mock *mock.Mock
}

func (_m *MockModuleLoadSystemRepositoryDelete) EXPECT() *MockModuleLoadSystemRepositoryDelete_Expecter {
	return &MockModuleLoadSystemRepositoryDelete_Expecter{mock: &_m.Mock}
}

// Exec provides a mock function for the type MockModuleLoadSystemRepositoryDelete
func (_mock *MockModuleLoadSystemRepositoryDelete) Exec(ctx context.Context, request *dao.ModuleDeleteRequest) (*dao.Module, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for Exec")
	}

	var r0 *dao.Module
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *dao.ModuleDeleteRequest) (*dao.Module, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *dao.ModuleDeleteRequest) *dao.Module); ok {
		r0 = returnFunc(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dao.Module)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *dao.ModuleDeleteRequest) error); ok {
		r1 = returnFunc(ctx, request)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockModuleLoadSystemRepositoryDelete_Exec_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exec'
type MockModuleLoadSystemRepositoryDelete_Exec_Call struct {
	*mock.Call
}

// Exec is a helper method to define mock.On call
//   - ctx context.Context
//   - request *dao.ModuleDeleteRequest
func (_e *MockModuleLoadSystemRepositoryDelete_Expecter) Exec(ctx interface{}, request interface{}) *MockModuleLoadSystemRepositoryDelete_Exec_Call {
	return &MockModuleLoadSystemRepositoryDelete_Exec_Call{Call: _e.mock.On("Exec", ctx, request)}
}

func (_c *MockModuleLoadSystemRepositoryDelete_Exec_Call) Run(run func(ctx context.Context, request *dao.ModuleDeleteRequest)) *MockModuleLoadSystemRepositoryDelete_Exec_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *dao.ModuleDeleteRequest
		if args[1] != nil {
			arg1 = args[1].(*dao.ModuleDeleteRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockModuleLoadSystemRepositoryDelete_Exec_Call) Return(module *dao.Module, err error) *MockModuleLoadSystemRepositoryDelete_Exec_Call {
	_c.Call.Return(module, err)
	return _c
}

func (_c *MockModuleLoadSystemRepositoryDelete_Exec_Call) RunAndReturn(run func(ctx context.Context, request *dao.ModuleDeleteRequest) (*dao.Module, error)) *MockModuleLoadSystemRepositoryDelete_Exec_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockModuleLoadSystemRepositorySelect creates a new instance of MockModuleLoadSystemRepositorySelect. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockModuleLoadSystemRepositorySelect(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockModuleLoadSystemRepositorySelect {
	mock := &MockModuleLoadSystemRepositorySelect{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockModuleLoadSystemRepositorySelect is an autogenerated mock type for the ModuleLoadSystemRepositorySelect type
type MockModuleLoadSystemRepositorySelect struct {
	mock.Mock
}

type MockModuleLoadSystemRepositorySelect_Expecter struct {
	mock *mock.Mock
}

func (_m *MockModuleLoadSystemRepositorySelect) EXPECT() *MockModuleLoadSystemRepositorySelect_Expecter {
	return &MockModuleLoadSystemRepositorySelect_Expecter{mock: &_m.Mock}
}

// Exec provides a mock function for the type MockModuleLoadSystemRepositorySelect
func (_mock *MockModuleLoadSystemRepositorySelect) Exec(ctx context.Context, request *dao.ModuleSelectRequest) (*dao.Module, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for Exec")
	}

	var r0 *dao.Module
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *dao.ModuleSelectRequest) (*dao.Module, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *dao.ModuleSelectRequest) *dao.Module); ok {
		r0 = returnFunc(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dao.Module)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *dao.ModuleSelectRequest) error); ok {
		r1 = returnFunc(ctx, request)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockModuleLoadSystemRepositorySelect_Exec_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exec'
type MockModuleLoadSystemRepositorySelect_Exec_Call struct {
	*mock.Call
}

// Exec is a helper method to define mock.On call
//   - ctx context.Context
//   - request *dao.ModuleSelectRequest
func (_e *MockModuleLoadSystemRepositorySelect_Expecter) Exec(ctx interface{}, request interface{}) *MockModuleLoadSystemRepositorySelect_Exec_Call {
	return &MockModuleLoadSystemRepositorySelect_Exec_Call{Call: _e.mock.On("Exec", ctx, request)}
}

func (_c *MockModuleLoadSystemRepositorySelect_Exec_Call) Run(run func(ctx context.Context, request *dao.ModuleSelectRequest)) *MockModuleLoadSystemRepositorySelect_Exec_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *dao.ModuleSelectRequest
		if args[1] != nil {
			arg1 = args[1].(*dao.ModuleSelectRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockModuleLoadSystemRepositorySelect_Exec_Call) Return(module *dao.Module, err error) *MockModuleLoadSystemRepositorySelect_Exec_Call {
	_c.Call.Return(module, err)
	return _c
}

func (_c *MockModuleLoadSystemRepositorySelect_Exec_Call) RunAndReturn(run func(ctx context.Context, request *dao.ModuleSelectRequest) (*dao.Module, error)) *MockModuleLoadSystemRepositorySelect_Exec_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockModuleLoadSystemRepositoryListVersions creates a new instance of MockModuleLoadSystemRepositoryListVersions. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockModuleLoadSystemRepositoryListVersions(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockModuleLoadSystemRepositoryListVersions {
	mock := &MockModuleLoadSystemRepositoryListVersions{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockModuleLoadSystemRepositoryListVersions is an autogenerated mock type for the ModuleLoadSystemRepositoryListVersions type
type MockModuleLoadSystemRepositoryListVersions struct {
	mock.Mock
}

type MockModuleLoadSystemRepositoryListVersions_Expecter struct {
	mock *mock.Mock
}

func (_m *MockModuleLoadSystemRepositoryListVersions) EXPECT() *MockModuleLoadSystemRepositoryListVersions_Expecter {
	return &MockModuleLoadSystemRepositoryListVersions_Expecter{mock: &_m.Mock}
}

// Exec provides a mock function for the type MockModuleLoadSystemRepositoryListVersions
func (_mock *MockModuleLoadSystemRepositoryListVersions) Exec(ctx context.Context, request *dao.ModuleListVersionsRequest) ([]*dao.ModuleVersion, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for Exec")
	}

	var r0 []*dao.ModuleVersion
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *dao.ModuleListVersionsRequest) ([]*dao.ModuleVersion, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *dao.ModuleListVersionsRequest) []*dao.ModuleVersion); ok {
		r0 = returnFunc(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*dao.ModuleVersion)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *dao.ModuleListVersionsRequest) error); ok {
		r1 = returnFunc(ctx, request)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockModuleLoadSystemRepositoryListVersions_Exec_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exec'
type MockModuleLoadSystemRepositoryListVersions_Exec_Call struct {
	*mock.Call
}

// Exec is a helper method to define mock.On call
//   - ctx context.Context
//   - request *dao.ModuleListVersionsRequest
func (_e *MockModuleLoadSystemRepositoryListVersions_Expecter) Exec(ctx interface{}, request interface{}) *MockModuleLoadSystemRepositoryListVersions_Exec_Call {
	return &MockModuleLoadSystemRepositoryListVersions_Exec_Call{Call: _e.mock.On("Exec", ctx, request)}
}

func (_c *MockModuleLoadSystemRepositoryListVersions_Exec_Call) Run(run func(ctx context.Context, request *dao.ModuleListVersionsRequest)) *MockModuleLoadSystemRepositoryListVersions_Exec_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *dao.ModuleListVersionsRequest
		if args[1] != nil {
			arg1 = args[1].(*dao.ModuleListVersionsRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockModuleLoadSystemRepositoryListVersions_Exec_Call) Return(moduleVersions []*dao.ModuleVersion, err error) *MockModuleLoadSystemRepositoryListVersions_Exec_Call {
	_c.Call.Return(moduleVersions, err)
	return _c
}

func (_c *MockModuleLoadSystemRepositoryListVersions_Exec_Call) RunAndReturn(run func(ctx context.Context, request *dao.ModuleListVersionsRequest) ([]*dao.ModuleVersion, error)) *MockModuleLoadSystemRepositoryListVersions_Exec_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockModuleSelectRepository creates a new instance of MockModuleSelectRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockModuleSelectRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockModuleSelectRepository {
	mock := &MockModuleSelectRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockModuleSelectRepository is an autogenerated mock type for the ModuleSelectRepository type
type MockModuleSelectRepository struct {
	mock.Mock
}

type MockModuleSelectRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockModuleSelectRepository) EXPECT() *MockModuleSelectRepository_Expecter {
	return &MockModuleSelectRepository_Expecter{mock: &_m.Mock}
}

// Exec provides a mock function for the type MockModuleSelectRepository
func (_mock *MockModuleSelectRepository) Exec(ctx context.Context, request *dao.ModuleSelectRequest) (*dao.Module, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for Exec")
	}

	var r0 *dao.Module
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *dao.ModuleSelectRequest) (*dao.Module, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *dao.ModuleSelectRequest) *dao.Module); ok {
		r0 = returnFunc(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dao.Module)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *dao.ModuleSelectRequest) error); ok {
		r1 = returnFunc(ctx, request)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockModuleSelectRepository_Exec_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exec'
type MockModuleSelectRepository_Exec_Call struct {
	*mock.Call
}

// Exec is a helper method to define mock.On call
//   - ctx context.Context
//   - request *dao.ModuleSelectRequest
func (_e *MockModuleSelectRepository_Expecter) Exec(ctx interface{}, request interface{}) *MockModuleSelectRepository_Exec_Call {
	return &MockModuleSelectRepository_Exec_Call{Call: _e.mock.On("Exec", ctx, request)}
}

func (_c *MockModuleSelectRepository_Exec_Call) Run(run func(ctx context.Context, request *dao.ModuleSelectRequest)) *MockModuleSelectRepository_Exec_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *dao.ModuleSelectRequest
		if args[1] != nil {
			arg1 = args[1].(*dao.ModuleSelectRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockModuleSelectRepository_Exec_Call) Return(module *dao.Module, err error) *MockModuleSelectRepository_Exec_Call {
	_c.Call.Return(module, err)
	return _c
}

func (_c *MockModuleSelectRepository_Exec_Call) RunAndReturn(run func(ctx context.Context, request *dao.ModuleSelectRequest) (*dao.Module, error)) *MockModuleSelectRepository_Exec_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockProjectDeleteRepositorySelect creates a new instance of MockProjectDeleteRepositorySelect. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockProjectDeleteRepositorySelect(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockProjectDeleteRepositorySelect {
	mock := &MockProjectDeleteRepositorySelect{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockProjectDeleteRepositorySelect is an autogenerated mock type for the ProjectDeleteRepositorySelect type
type MockProjectDeleteRepositorySelect struct {
	mock.Mock
}

type MockProjectDeleteRepositorySelect_Expecter struct {
	mock *mock.Mock
}

func (_m *MockProjectDeleteRepositorySelect) EXPECT() *MockProjectDeleteRepositorySelect_Expecter {
	return &MockProjectDeleteRepositorySelect_Expecter{mock: &_m.Mock}
}

// Exec provides a mock function for the type MockProjectDeleteRepositorySelect
func (_mock *MockProjectDeleteRepositorySelect) Exec(ctx context.Context, request *dao.ProjectSelectRequest) (*dao.Project, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for Exec")
	}

	var r0 *dao.Project
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *dao.ProjectSelectRequest) (*dao.Project, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *dao.ProjectSelectRequest) *dao.Project); ok {
		r0 = returnFunc(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dao.Project)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *dao.ProjectSelectRequest) error); ok {
		r1 = returnFunc(ctx, request)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockProjectDeleteRepositorySelect_Exec_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exec'
type MockProjectDeleteRepositorySelect_Exec_Call struct {
	*mock.Call
}

// Exec is a helper method to define mock.On call
//   - ctx context.Context
//   - request *dao.ProjectSelectRequest
func (_e *MockProjectDeleteRepositorySelect_Expecter) Exec(ctx interface{}, request interface{}) *MockProjectDeleteRepositorySelect_Exec_Call {
	return &MockProjectDeleteRepositorySelect_Exec_Call{Call: _e.mock.On("Exec", ctx, request)}
}

func (_c *MockProjectDeleteRepositorySelect_Exec_Call) Run(run func(ctx context.Context, request *dao.ProjectSelectRequest)) *MockProjectDeleteRepositorySelect_Exec_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *dao.ProjectSelectRequest
		if args[1] != nil {
			arg1 = args[1].(*dao.ProjectSelectRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockProjectDeleteRepositorySelect_Exec_Call) Return(project *dao.Project, err error) *MockProjectDeleteRepositorySelect_Exec_Call {
	_c.Call.Return(project, err)
	return _c
}

func (_c *MockProjectDeleteRepositorySelect_Exec_Call) RunAndReturn(run func(ctx context.Context, request *dao.ProjectSelectRequest) (*dao.Project, error)) *MockProjectDeleteRepositorySelect_Exec_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockProjectDeleteRepository creates a new instance of MockProjectDeleteRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockProjectDeleteRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockProjectDeleteRepository {
	mock := &MockProjectDeleteRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockProjectDeleteRepository is an autogenerated mock type for the ProjectDeleteRepository type
type MockProjectDeleteRepository struct {
	mock.Mock
}

type MockProjectDeleteRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockProjectDeleteRepository) EXPECT() *MockProjectDeleteRepository_Expecter {
	return &MockProjectDeleteRepository_Expecter{mock: &_m.Mock}
}

// Exec provides a mock function for the type MockProjectDeleteRepository
func (_mock *MockProjectDeleteRepository) Exec(ctx context.Context, request *dao.ProjectDeleteRequest) (*dao.Project, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for Exec")
	}

	var r0 *dao.Project
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *dao.ProjectDeleteRequest) (*dao.Project, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *dao.ProjectDeleteRequest) *dao.Project); ok {
		r0 = returnFunc(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dao.Project)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *dao.ProjectDeleteRequest) error); ok {
		r1 = returnFunc(ctx, request)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockProjectDeleteRepository_Exec_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exec'
type MockProjectDeleteRepository_Exec_Call struct {
	*mock.Call
}

// Exec is a helper method to define mock.On call
//   - ctx context.Context
//   - request *dao.ProjectDeleteRequest
func (_e *MockProjectDeleteRepository_Expecter) Exec(ctx interface{}, request interface{}) *MockProjectDeleteRepository_Exec_Call {
	return &MockProjectDeleteRepository_Exec_Call{Call: _e.mock.On("Exec", ctx, request)}
}

func (_c *MockProjectDeleteRepository_Exec_Call) Run(run func(ctx context.Context, request *dao.ProjectDeleteRequest)) *MockProjectDeleteRepository_Exec_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *dao.ProjectDeleteRequest
		if args[1] != nil {
			arg1 = args[1].(*dao.ProjectDeleteRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockProjectDeleteRepository_Exec_Call) Return(project *dao.Project, err error) *MockProjectDeleteRepository_Exec_Call {
	_c.Call.Return(project, err)
	return _c
}

func (_c *MockProjectDeleteRepository_Exec_Call) RunAndReturn(run func(ctx context.Context, request *dao.ProjectDeleteRequest) (*dao.Project, error)) *MockProjectDeleteRepository_Exec_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockProjectInsertRepository creates a new instance of MockProjectInsertRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockProjectInsertRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockProjectInsertRepository {
	mock := &MockProjectInsertRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockProjectInsertRepository is an autogenerated mock type for the ProjectInsertRepository type
type MockProjectInsertRepository struct {
	mock.Mock
}

type MockProjectInsertRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockProjectInsertRepository) EXPECT() *MockProjectInsertRepository_Expecter {
	return &MockProjectInsertRepository_Expecter{mock: &_m.Mock}
}

// Exec provides a mock function for the type MockProjectInsertRepository
func (_mock *MockProjectInsertRepository) Exec(ctx context.Context, request *dao.ProjectInsertRequest) (*dao.Project, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for Exec")
	}

	var r0 *dao.Project
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *dao.ProjectInsertRequest) (*dao.Project, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *dao.ProjectInsertRequest) *dao.Project); ok {
		r0 = returnFunc(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dao.Project)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *dao.ProjectInsertRequest) error); ok {
		r1 = returnFunc(ctx, request)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockProjectInsertRepository_Exec_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exec'
type MockProjectInsertRepository_Exec_Call struct {
	*mock.Call
}

// Exec is a helper method to define mock.On call
//   - ctx context.Context
//   - request *dao.ProjectInsertRequest
func (_e *MockProjectInsertRepository_Expecter) Exec(ctx interface{}, request interface{}) *MockProjectInsertRepository_Exec_Call {
	return &MockProjectInsertRepository_Exec_Call{Call: _e.mock.On("Exec", ctx, request)}
}

func (_c *MockProjectInsertRepository_Exec_Call) Run(run func(ctx context.Context, request *dao.ProjectInsertRequest)) *MockProjectInsertRepository_Exec_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *dao.ProjectInsertRequest
		if args[1] != nil {
			arg1 = args[1].(*dao.ProjectInsertRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockProjectInsertRepository_Exec_Call) Return(project *dao.Project, err error) *MockProjectInsertRepository_Exec_Call {
	_c.Call.Return(project, err)
	return _c
}

func (_c *MockProjectInsertRepository_Exec_Call) RunAndReturn(run func(ctx context.Context, request *dao.ProjectInsertRequest) (*dao.Project, error)) *MockProjectInsertRepository_Exec_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockProjectInsertRepositorySchemaInsert creates a new instance of MockProjectInsertRepositorySchemaInsert. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockProjectInsertRepositorySchemaInsert(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockProjectInsertRepositorySchemaInsert {
	mock := &MockProjectInsertRepositorySchemaInsert{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockProjectInsertRepositorySchemaInsert is an autogenerated mock type for the ProjectInsertRepositorySchemaInsert type
type MockProjectInsertRepositorySchemaInsert struct {
	mock.Mock
}

type MockProjectInsertRepositorySchemaInsert_Expecter struct {
	mock *mock.Mock
}

func (_m *MockProjectInsertRepositorySchemaInsert) EXPECT() *MockProjectInsertRepositorySchemaInsert_Expecter {
	return &MockProjectInsertRepositorySchemaInsert_Expecter{mock: &_m.Mock}
}

// Exec provides a mock function for the type MockProjectInsertRepositorySchemaInsert
func (_mock *MockProjectInsertRepositorySchemaInsert) Exec(ctx context.Context, request *dao.SchemaInsertRequest) (*dao.Schema, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for Exec")
	}

	var r0 *dao.Schema
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *dao.SchemaInsertRequest) (*dao.Schema, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *dao.SchemaInsertRequest) *dao.Schema); ok {
		r0 = returnFunc(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dao.Schema)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *dao.SchemaInsertRequest) error); ok {
		r1 = returnFunc(ctx, request)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockProjectInsertRepositorySchemaInsert_Exec_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exec'
type MockProjectInsertRepositorySchemaInsert_Exec_Call struct {
	*mock.Call
}

// Exec is a helper method to define mock.On call
//   - ctx context.Context
//   - request *dao.SchemaInsertRequest
func (_e *MockProjectInsertRepositorySchemaInsert_Expecter) Exec(ctx interface{}, request interface{}) *MockProjectInsertRepositorySchemaInsert_Exec_Call {
	return &MockProjectInsertRepositorySchemaInsert_Exec_Call{Call: _e.mock.On("Exec", ctx, request)}
}

func (_c *MockProjectInsertRepositorySchemaInsert_Exec_Call) Run(run func(ctx context.Context, request *dao.SchemaInsertRequest)) *MockProjectInsertRepositorySchemaInsert_Exec_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *dao.SchemaInsertRequest
		if args[1] != nil {
			arg1 = args[1].(*dao.SchemaInsertRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockProjectInsertRepositorySchemaInsert_Exec_Call) Return(schema *dao.Schema, err error) *MockProjectInsertRepositorySchemaInsert_Exec_Call {
	_c.Call.Return(schema, err)
	return _c
}

func (_c *MockProjectInsertRepositorySchemaInsert_Exec_Call) RunAndReturn(run func(ctx context.Context, request *dao.SchemaInsertRequest) (*dao.Schema, error)) *MockProjectInsertRepositorySchemaInsert_Exec_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockProjectInsertRepositoryModuleExists creates a new instance of MockProjectInsertRepositoryModuleExists. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockProjectInsertRepositoryModuleExists(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockProjectInsertRepositoryModuleExists {
	mock := &MockProjectInsertRepositoryModuleExists{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockProjectInsertRepositoryModuleExists is an autogenerated mock type for the ProjectInsertRepositoryModuleExists type
type MockProjectInsertRepositoryModuleExists struct {
	mock.Mock
}

type MockProjectInsertRepositoryModuleExists_Expecter struct {
	mock *mock.Mock
}

func (_m *MockProjectInsertRepositoryModuleExists) EXPECT() *MockProjectInsertRepositoryModuleExists_Expecter {
	return &MockProjectInsertRepositoryModuleExists_Expecter{mock: &_m.Mock}
}

// Exec provides a mock function for the type MockProjectInsertRepositoryModuleExists
func (_mock *MockProjectInsertRepositoryModuleExists) Exec(ctx context.Context, request *dao.ModuleSelectRequest) (bool, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for Exec")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *dao.ModuleSelectRequest) (bool, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *dao.ModuleSelectRequest) bool); ok {
		r0 = returnFunc(ctx, request)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *dao.ModuleSelectRequest) error); ok {
		r1 = returnFunc(ctx, request)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockProjectInsertRepositoryModuleExists_Exec_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exec'
type MockProjectInsertRepositoryModuleExists_Exec_Call struct {
	*mock.Call
}

// Exec is a helper method to define mock.On call
//   - ctx context.Context
//   - request *dao.ModuleSelectRequest
func (_e *MockProjectInsertRepositoryModuleExists_Expecter) Exec(ctx interface{}, request interface{}) *MockProjectInsertRepositoryModuleExists_Exec_Call {
	return &MockProjectInsertRepositoryModuleExists_Exec_Call{Call: _e.mock.On("Exec", ctx, request)}
}

func (_c *MockProjectInsertRepositoryModuleExists_Exec_Call) Run(run func(ctx context.Context, request *dao.ModuleSelectRequest)) *MockProjectInsertRepositoryModuleExists_Exec_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *dao.ModuleSelectRequest
		if args[1] != nil {
			arg1 = args[1].(*dao.ModuleSelectRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockProjectInsertRepositoryModuleExists_Exec_Call) Return(b bool, err error) *MockProjectInsertRepositoryModuleExists_Exec_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *MockProjectInsertRepositoryModuleExists_Exec_Call) RunAndReturn(run func(ctx context.Context, request *dao.ModuleSelectRequest) (bool, error)) *MockProjectInsertRepositoryModuleExists_Exec_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockProjectListRepository creates a new instance of MockProjectListRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockProjectListRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockProjectListRepository {
	mock := &MockProjectListRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockProjectListRepository is an autogenerated mock type for the ProjectListRepository type
type MockProjectListRepository struct {
	mock.Mock
}

type MockProjectListRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockProjectListRepository) EXPECT() *MockProjectListRepository_Expecter {
	return &MockProjectListRepository_Expecter{mock: &_m.Mock}
}

// Exec provides a mock function for the type MockProjectListRepository
func (_mock *MockProjectListRepository) Exec(ctx context.Context, request *dao.ProjectListRequest) ([]*dao.Project, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for Exec")
	}

	var r0 []*dao.Project
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *dao.ProjectListRequest) ([]*dao.Project, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *dao.ProjectListRequest) []*dao.Project); ok {
		r0 = returnFunc(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*dao.Project)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *dao.ProjectListRequest) error); ok {
		r1 = returnFunc(ctx, request)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockProjectListRepository_Exec_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exec'
type MockProjectListRepository_Exec_Call struct {
	*mock.Call
}

// Exec is a helper method to define mock.On call
//   - ctx context.Context
//   - request *dao.ProjectListRequest
func (_e *MockProjectListRepository_Expecter) Exec(ctx interface{}, request interface{}) *MockProjectListRepository_Exec_Call {
	return &MockProjectListRepository_Exec_Call{Call: _e.mock.On("Exec", ctx, request)}
}

func (_c *MockProjectListRepository_Exec_Call) Run(run func(ctx context.Context, request *dao.ProjectListRequest)) *MockProjectListRepository_Exec_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *dao.ProjectListRequest
		if args[1] != nil {
			arg1 = args[1].(*dao.ProjectListRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockProjectListRepository_Exec_Call) Return(projects []*dao.Project, err error) *MockProjectListRepository_Exec_Call {
	_c.Call.Return(projects, err)
	return _c
}

func (_c *MockProjectListRepository_Exec_Call) RunAndReturn(run func(ctx context.Context, request *dao.ProjectListRequest) ([]*dao.Project, error)) *MockProjectListRepository_Exec_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockProjectSelectRepository creates a new instance of MockProjectSelectRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockProjectSelectRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockProjectSelectRepository {
	mock := &MockProjectSelectRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockProjectSelectRepository is an autogenerated mock type for the ProjectSelectRepository type
type MockProjectSelectRepository struct {
	mock.Mock
}

type MockProjectSelectRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockProjectSelectRepository) EXPECT() *MockProjectSelectRepository_Expecter {
	return &MockProjectSelectRepository_Expecter{mock: &_m.Mock}
}

// Exec provides a mock function for the type MockProjectSelectRepository
func (_mock *MockProjectSelectRepository) Exec(ctx context.Context, request *dao.ProjectSelectRequest) (*dao.Project, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for Exec")
	}

	var r0 *dao.Project
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *dao.ProjectSelectRequest) (*dao.Project, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *dao.ProjectSelectRequest) *dao.Project); ok {
		r0 = returnFunc(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dao.Project)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *dao.ProjectSelectRequest) error); ok {
		r1 = returnFunc(ctx, request)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockProjectSelectRepository_Exec_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exec'
type MockProjectSelectRepository_Exec_Call struct {
	*mock.Call
}

// Exec is a helper method to define mock.On call
//   - ctx context.Context
//   - request *dao.ProjectSelectRequest
func (_e *MockProjectSelectRepository_Expecter) Exec(ctx interface{}, request interface{}) *MockProjectSelectRepository_Exec_Call {
	return &MockProjectSelectRepository_Exec_Call{Call: _e.mock.On("Exec", ctx, request)}
}

func (_c *MockProjectSelectRepository_Exec_Call) Run(run func(ctx context.Context, request *dao.ProjectSelectRequest)) *MockProjectSelectRepository_Exec_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *dao.ProjectSelectRequest
		if args[1] != nil {
			arg1 = args[1].(*dao.ProjectSelectRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockProjectSelectRepository_Exec_Call) Return(project *dao.Project, err error) *MockProjectSelectRepository_Exec_Call {
	_c.Call.Return(project, err)
	return _c
}

func (_c *MockProjectSelectRepository_Exec_Call) RunAndReturn(run func(ctx context.Context, request *dao.ProjectSelectRequest) (*dao.Project, error)) *MockProjectSelectRepository_Exec_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockProjectUpdateRepositorySelect creates a new instance of MockProjectUpdateRepositorySelect. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockProjectUpdateRepositorySelect(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockProjectUpdateRepositorySelect {
	mock := &MockProjectUpdateRepositorySelect{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockProjectUpdateRepositorySelect is an autogenerated mock type for the ProjectUpdateRepositorySelect type
type MockProjectUpdateRepositorySelect struct {
	mock.Mock
}

type MockProjectUpdateRepositorySelect_Expecter struct {
	mock *mock.Mock
}

func (_m *MockProjectUpdateRepositorySelect) EXPECT() *MockProjectUpdateRepositorySelect_Expecter {
	return &MockProjectUpdateRepositorySelect_Expecter{mock: &_m.Mock}
}

// Exec provides a mock function for the type MockProjectUpdateRepositorySelect
func (_mock *MockProjectUpdateRepositorySelect) Exec(ctx context.Context, request *dao.ProjectSelectRequest) (*dao.Project, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for Exec")
	}

	var r0 *dao.Project
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *dao.ProjectSelectRequest) (*dao.Project, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *dao.ProjectSelectRequest) *dao.Project); ok {
		r0 = returnFunc(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dao.Project)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *dao.ProjectSelectRequest) error); ok {
		r1 = returnFunc(ctx, request)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockProjectUpdateRepositorySelect_Exec_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exec'
type MockProjectUpdateRepositorySelect_Exec_Call struct {
	*mock.Call
}

// Exec is a helper method to define mock.On call
//   - ctx context.Context
//   - request *dao.ProjectSelectRequest
func (_e *MockProjectUpdateRepositorySelect_Expecter) Exec(ctx interface{}, request interface{}) *MockProjectUpdateRepositorySelect_Exec_Call {
	return &MockProjectUpdateRepositorySelect_Exec_Call{Call: _e.mock.On("Exec", ctx, request)}
}

func (_c *MockProjectUpdateRepositorySelect_Exec_Call) Run(run func(ctx context.Context, request *dao.ProjectSelectRequest)) *MockProjectUpdateRepositorySelect_Exec_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *dao.ProjectSelectRequest
		if args[1] != nil {
			arg1 = args[1].(*dao.ProjectSelectRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockProjectUpdateRepositorySelect_Exec_Call) Return(project *dao.Project, err error) *MockProjectUpdateRepositorySelect_Exec_Call {
	_c.Call.Return(project, err)
	return _c
}

func (_c *MockProjectUpdateRepositorySelect_Exec_Call) RunAndReturn(run func(ctx context.Context, request *dao.ProjectSelectRequest) (*dao.Project, error)) *MockProjectUpdateRepositorySelect_Exec_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockProjectUpdateRepository creates a new instance of MockProjectUpdateRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockProjectUpdateRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockProjectUpdateRepository {
	mock := &MockProjectUpdateRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockProjectUpdateRepository is an autogenerated mock type for the ProjectUpdateRepository type
type MockProjectUpdateRepository struct {
	mock.Mock
}

type MockProjectUpdateRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockProjectUpdateRepository) EXPECT() *MockProjectUpdateRepository_Expecter {
	return &MockProjectUpdateRepository_Expecter{mock: &_m.Mock}
}

// Exec provides a mock function for the type MockProjectUpdateRepository
func (_mock *MockProjectUpdateRepository) Exec(ctx context.Context, request *dao.ProjectUpdateRequest) (*dao.Project, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for Exec")
	}

	var r0 *dao.Project
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *dao.ProjectUpdateRequest) (*dao.Project, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *dao.ProjectUpdateRequest) *dao.Project); ok {
		r0 = returnFunc(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dao.Project)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *dao.ProjectUpdateRequest) error); ok {
		r1 = returnFunc(ctx, request)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockProjectUpdateRepository_Exec_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exec'
type MockProjectUpdateRepository_Exec_Call struct {
	*mock.Call
}

// Exec is a helper method to define mock.On call
//   - ctx context.Context
//   - request *dao.ProjectUpdateRequest
func (_e *MockProjectUpdateRepository_Expecter) Exec(ctx interface{}, request interface{}) *MockProjectUpdateRepository_Exec_Call {
	return &MockProjectUpdateRepository_Exec_Call{Call: _e.mock.On("Exec", ctx, request)}
}

func (_c *MockProjectUpdateRepository_Exec_Call) Run(run func(ctx context.Context, request *dao.ProjectUpdateRequest)) *MockProjectUpdateRepository_Exec_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *dao.ProjectUpdateRequest
		if args[1] != nil {
			arg1 = args[1].(*dao.ProjectUpdateRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockProjectUpdateRepository_Exec_Call) Return(project *dao.Project, err error) *MockProjectUpdateRepository_Exec_Call {
	_c.Call.Return(project, err)
	return _c
}

func (_c *MockProjectUpdateRepository_Exec_Call) RunAndReturn(run func(ctx context.Context, request *dao.ProjectUpdateRequest) (*dao.Project, error)) *MockProjectUpdateRepository_Exec_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockProjectUpdateRepositorySchemaInsert creates a new instance of MockProjectUpdateRepositorySchemaInsert. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockProjectUpdateRepositorySchemaInsert(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockProjectUpdateRepositorySchemaInsert {
	mock := &MockProjectUpdateRepositorySchemaInsert{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockProjectUpdateRepositorySchemaInsert is an autogenerated mock type for the ProjectUpdateRepositorySchemaInsert type
type MockProjectUpdateRepositorySchemaInsert struct {
	mock.Mock
}

type MockProjectUpdateRepositorySchemaInsert_Expecter struct {
	mock *mock.Mock
}

func (_m *MockProjectUpdateRepositorySchemaInsert) EXPECT() *MockProjectUpdateRepositorySchemaInsert_Expecter {
	return &MockProjectUpdateRepositorySchemaInsert_Expecter{mock: &_m.Mock}
}

// Exec provides a mock function for the type MockProjectUpdateRepositorySchemaInsert
func (_mock *MockProjectUpdateRepositorySchemaInsert) Exec(ctx context.Context, request *dao.SchemaInsertRequest) (*dao.Schema, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for Exec")
	}

	var r0 *dao.Schema
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *dao.SchemaInsertRequest) (*dao.Schema, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *dao.SchemaInsertRequest) *dao.Schema); ok {
		r0 = returnFunc(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dao.Schema)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *dao.SchemaInsertRequest) error); ok {
		r1 = returnFunc(ctx, request)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockProjectUpdateRepositorySchemaInsert_Exec_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exec'
type MockProjectUpdateRepositorySchemaInsert_Exec_Call struct {
	*mock.Call
}

// Exec is a helper method to define mock.On call
//   - ctx context.Context
//   - request *dao.SchemaInsertRequest
func (_e *MockProjectUpdateRepositorySchemaInsert_Expecter) Exec(ctx interface{}, request interface{}) *MockProjectUpdateRepositorySchemaInsert_Exec_Call {
	return &MockProjectUpdateRepositorySchemaInsert_Exec_Call{Call: _e.mock.On("Exec", ctx, request)}
}

func (_c *MockProjectUpdateRepositorySchemaInsert_Exec_Call) Run(run func(ctx context.Context, request *dao.SchemaInsertRequest)) *MockProjectUpdateRepositorySchemaInsert_Exec_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *dao.SchemaInsertRequest
		if args[1] != nil {
			arg1 = args[1].(*dao.SchemaInsertRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockProjectUpdateRepositorySchemaInsert_Exec_Call) Return(schema *dao.Schema, err error) *MockProjectUpdateRepositorySchemaInsert_Exec_Call {
	_c.Call.Return(schema, err)
	return _c
}

func (_c *MockProjectUpdateRepositorySchemaInsert_Exec_Call) RunAndReturn(run func(ctx context.Context, request *dao.SchemaInsertRequest) (*dao.Schema, error)) *MockProjectUpdateRepositorySchemaInsert_Exec_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockProjectUpdateRepositoryModuleExists creates a new instance of MockProjectUpdateRepositoryModuleExists. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockProjectUpdateRepositoryModuleExists(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockProjectUpdateRepositoryModuleExists {
	mock := &MockProjectUpdateRepositoryModuleExists{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockProjectUpdateRepositoryModuleExists is an autogenerated mock type for the ProjectUpdateRepositoryModuleExists type
type MockProjectUpdateRepositoryModuleExists struct {
	mock.Mock
}

type MockProjectUpdateRepositoryModuleExists_Expecter struct {
	mock *mock.Mock
}

func (_m *MockProjectUpdateRepositoryModuleExists) EXPECT() *MockProjectUpdateRepositoryModuleExists_Expecter {
	return &MockProjectUpdateRepositoryModuleExists_Expecter{mock: &_m.Mock}
}

// Exec provides a mock function for the type MockProjectUpdateRepositoryModuleExists
func (_mock *MockProjectUpdateRepositoryModuleExists) Exec(ctx context.Context, request *dao.ModuleSelectRequest) (bool, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for Exec")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *dao.ModuleSelectRequest) (bool, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *dao.ModuleSelectRequest) bool); ok {
		r0 = returnFunc(ctx, request)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *dao.ModuleSelectRequest) error); ok {
		r1 = returnFunc(ctx, request)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockProjectUpdateRepositoryModuleExists_Exec_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exec'
type MockProjectUpdateRepositoryModuleExists_Exec_Call struct {
	*mock.Call
}

// Exec is a helper method to define mock.On call
//   - ctx context.Context
//   - request *dao.ModuleSelectRequest
func (_e *MockProjectUpdateRepositoryModuleExists_Expecter) Exec(ctx interface{}, request interface{}) *MockProjectUpdateRepositoryModuleExists_Exec_Call {
	return &MockProjectUpdateRepositoryModuleExists_Exec_Call{Call: _e.mock.On("Exec", ctx, request)}
}

func (_c *MockProjectUpdateRepositoryModuleExists_Exec_Call) Run(run func(ctx context.Context, request *dao.ModuleSelectRequest)) *MockProjectUpdateRepositoryModuleExists_Exec_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *dao.ModuleSelectRequest
		if args[1] != nil {
			arg1 = args[1].(*dao.ModuleSelectRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockProjectUpdateRepositoryModuleExists_Exec_Call) Return(b bool, err error) *MockProjectUpdateRepositoryModuleExists_Exec_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *MockProjectUpdateRepositoryModuleExists_Exec_Call) RunAndReturn(run func(ctx context.Context, request *dao.ModuleSelectRequest) (bool, error)) *MockProjectUpdateRepositoryModuleExists_Exec_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockSchemaCreateRepository creates a new instance of MockSchemaCreateRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockSchemaCreateRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockSchemaCreateRepository {
	mock := &MockSchemaCreateRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockSchemaCreateRepository is an autogenerated mock type for the SchemaCreateRepository type
type MockSchemaCreateRepository struct {
	mock.Mock
}

type MockSchemaCreateRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockSchemaCreateRepository) EXPECT() *MockSchemaCreateRepository_Expecter {
	return &MockSchemaCreateRepository_Expecter{mock: &_m.Mock}
}

// Exec provides a mock function for the type MockSchemaCreateRepository
func (_mock *MockSchemaCreateRepository) Exec(ctx context.Context, request *dao.SchemaInsertRequest) (*dao.Schema, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for Exec")
	}

	var r0 *dao.Schema
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *dao.SchemaInsertRequest) (*dao.Schema, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *dao.SchemaInsertRequest) *dao.Schema); ok {
		r0 = returnFunc(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dao.Schema)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *dao.SchemaInsertRequest) error); ok {
		r1 = returnFunc(ctx, request)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockSchemaCreateRepository_Exec_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exec'
type MockSchemaCreateRepository_Exec_Call struct {
	*mock.Call
}

// Exec is a helper method to define mock.On call
//   - ctx context.Context
//   - request *dao.SchemaInsertRequest
func (_e *MockSchemaCreateRepository_Expecter) Exec(ctx interface{}, request interface{}) *MockSchemaCreateRepository_Exec_Call {
	return &MockSchemaCreateRepository_Exec_Call{Call: _e.mock.On("Exec", ctx, request)}
}

func (_c *MockSchemaCreateRepository_Exec_Call) Run(run func(ctx context.Context, request *dao.SchemaInsertRequest)) *MockSchemaCreateRepository_Exec_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *dao.SchemaInsertRequest
		if args[1] != nil {
			arg1 = args[1].(*dao.SchemaInsertRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockSchemaCreateRepository_Exec_Call) Return(schema *dao.Schema, err error) *MockSchemaCreateRepository_Exec_Call {
	_c.Call.Return(schema, err)
	return _c
}

func (_c *MockSchemaCreateRepository_Exec_Call) RunAndReturn(run func(ctx context.Context, request *dao.SchemaInsertRequest) (*dao.Schema, error)) *MockSchemaCreateRepository_Exec_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockSchemaCreateRepositoryProjectSelect creates a new instance of MockSchemaCreateRepositoryProjectSelect. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockSchemaCreateRepositoryProjectSelect(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockSchemaCreateRepositoryProjectSelect {
	mock := &MockSchemaCreateRepositoryProjectSelect{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockSchemaCreateRepositoryProjectSelect is an autogenerated mock type for the SchemaCreateRepositoryProjectSelect type
type MockSchemaCreateRepositoryProjectSelect struct {
	mock.Mock
}

type MockSchemaCreateRepositoryProjectSelect_Expecter struct {
	mock *mock.Mock
}

func (_m *MockSchemaCreateRepositoryProjectSelect) EXPECT() *MockSchemaCreateRepositoryProjectSelect_Expecter {
	return &MockSchemaCreateRepositoryProjectSelect_Expecter{mock: &_m.Mock}
}

// Exec provides a mock function for the type MockSchemaCreateRepositoryProjectSelect
func (_mock *MockSchemaCreateRepositoryProjectSelect) Exec(ctx context.Context, request *dao.ProjectSelectRequest) (*dao.Project, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for Exec")
	}

	var r0 *dao.Project
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *dao.ProjectSelectRequest) (*dao.Project, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *dao.ProjectSelectRequest) *dao.Project); ok {
		r0 = returnFunc(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dao.Project)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *dao.ProjectSelectRequest) error); ok {
		r1 = returnFunc(ctx, request)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockSchemaCreateRepositoryProjectSelect_Exec_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exec'
type MockSchemaCreateRepositoryProjectSelect_Exec_Call struct {
	*mock.Call
}

// Exec is a helper method to define mock.On call
//   - ctx context.Context
//   - request *dao.ProjectSelectRequest
func (_e *MockSchemaCreateRepositoryProjectSelect_Expecter) Exec(ctx interface{}, request interface{}) *MockSchemaCreateRepositoryProjectSelect_Exec_Call {
	return &MockSchemaCreateRepositoryProjectSelect_Exec_Call{Call: _e.mock.On("Exec", ctx, request)}
}

func (_c *MockSchemaCreateRepositoryProjectSelect_Exec_Call) Run(run func(ctx context.Context, request *dao.ProjectSelectRequest)) *MockSchemaCreateRepositoryProjectSelect_Exec_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *dao.ProjectSelectRequest
		if args[1] != nil {
			arg1 = args[1].(*dao.ProjectSelectRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockSchemaCreateRepositoryProjectSelect_Exec_Call) Return(project *dao.Project, err error) *MockSchemaCreateRepositoryProjectSelect_Exec_Call {
	_c.Call.Return(project, err)
	return _c
}

func (_c *MockSchemaCreateRepositoryProjectSelect_Exec_Call) RunAndReturn(run func(ctx context.Context, request *dao.ProjectSelectRequest) (*dao.Project, error)) *MockSchemaCreateRepositoryProjectSelect_Exec_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockSchemaCreateRepositoryModuleSelect creates a new instance of MockSchemaCreateRepositoryModuleSelect. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockSchemaCreateRepositoryModuleSelect(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockSchemaCreateRepositoryModuleSelect {
	mock := &MockSchemaCreateRepositoryModuleSelect{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockSchemaCreateRepositoryModuleSelect is an autogenerated mock type for the SchemaCreateRepositoryModuleSelect type
type MockSchemaCreateRepositoryModuleSelect struct {
	mock.Mock
}

type MockSchemaCreateRepositoryModuleSelect_Expecter struct {
	mock *mock.Mock
}

func (_m *MockSchemaCreateRepositoryModuleSelect) EXPECT() *MockSchemaCreateRepositoryModuleSelect_Expecter {
	return &MockSchemaCreateRepositoryModuleSelect_Expecter{mock: &_m.Mock}
}

// Exec provides a mock function for the type MockSchemaCreateRepositoryModuleSelect
func (_mock *MockSchemaCreateRepositoryModuleSelect) Exec(ctx context.Context, request *dao.ModuleSelectRequest) (*dao.Module, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for Exec")
	}

	var r0 *dao.Module
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *dao.ModuleSelectRequest) (*dao.Module, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *dao.ModuleSelectRequest) *dao.Module); ok {
		r0 = returnFunc(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dao.Module)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *dao.ModuleSelectRequest) error); ok {
		r1 = returnFunc(ctx, request)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockSchemaCreateRepositoryModuleSelect_Exec_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exec'
type MockSchemaCreateRepositoryModuleSelect_Exec_Call struct {
	*mock.Call
}

// Exec is a helper method to define mock.On call
//   - ctx context.Context
//   - request *dao.ModuleSelectRequest
func (_e *MockSchemaCreateRepositoryModuleSelect_Expecter) Exec(ctx interface{}, request interface{}) *MockSchemaCreateRepositoryModuleSelect_Exec_Call {
	return &MockSchemaCreateRepositoryModuleSelect_Exec_Call{Call: _e.mock.On("Exec", ctx, request)}
}

func (_c *MockSchemaCreateRepositoryModuleSelect_Exec_Call) Run(run func(ctx context.Context, request *dao.ModuleSelectRequest)) *MockSchemaCreateRepositoryModuleSelect_Exec_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *dao.ModuleSelectRequest
		if args[1] != nil {
			arg1 = args[1].(*dao.ModuleSelectRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockSchemaCreateRepositoryModuleSelect_Exec_Call) Return(module *dao.Module, err error) *MockSchemaCreateRepositoryModuleSelect_Exec_Call {
	_c.Call.Return(module, err)
	return _c
}

func (_c *MockSchemaCreateRepositoryModuleSelect_Exec_Call) RunAndReturn(run func(ctx context.Context, request *dao.ModuleSelectRequest) (*dao.Module, error)) *MockSchemaCreateRepositoryModuleSelect_Exec_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockSchemaGenerateRepository creates a new instance of MockSchemaGenerateRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockSchemaGenerateRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockSchemaGenerateRepository {
	mock := &MockSchemaGenerateRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockSchemaGenerateRepository is an autogenerated mock type for the SchemaGenerateRepository type
type MockSchemaGenerateRepository struct {
	mock.Mock
}

type MockSchemaGenerateRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockSchemaGenerateRepository) EXPECT() *MockSchemaGenerateRepository_Expecter {
	return &MockSchemaGenerateRepository_Expecter{mock: &_m.Mock}
}

// Exec provides a mock function for the type MockSchemaGenerateRepository
func (_mock *MockSchemaGenerateRepository) Exec(ctx context.Context, request *dao.ModuleGenerateRequest) (map[string]any, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for Exec")
	}

	var r0 map[string]any
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *dao.ModuleGenerateRequest) (map[string]any, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *dao.ModuleGenerateRequest) map[string]any); ok {
		r0 = returnFunc(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]any)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *dao.ModuleGenerateRequest) error); ok {
		r1 = returnFunc(ctx, request)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockSchemaGenerateRepository_Exec_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exec'
type MockSchemaGenerateRepository_Exec_Call struct {
	*mock.Call
}

// Exec is a helper method to define mock.On call
//   - ctx context.Context
//   - request *dao.ModuleGenerateRequest
func (_e *MockSchemaGenerateRepository_Expecter) Exec(ctx interface{}, request interface{}) *MockSchemaGenerateRepository_Exec_Call {
	return &MockSchemaGenerateRepository_Exec_Call{Call: _e.mock.On("Exec", ctx, request)}
}

func (_c *MockSchemaGenerateRepository_Exec_Call) Run(run func(ctx context.Context, request *dao.ModuleGenerateRequest)) *MockSchemaGenerateRepository_Exec_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *dao.ModuleGenerateRequest
		if args[1] != nil {
			arg1 = args[1].(*dao.ModuleGenerateRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockSchemaGenerateRepository_Exec_Call) Return(stringToV map[string]any, err error) *MockSchemaGenerateRepository_Exec_Call {
	_c.Call.Return(stringToV, err)
	return _c
}

func (_c *MockSchemaGenerateRepository_Exec_Call) RunAndReturn(run func(ctx context.Context, request *dao.ModuleGenerateRequest) (map[string]any, error)) *MockSchemaGenerateRepository_Exec_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockSchemaGenerateRepositorySchemaList creates a new instance of MockSchemaGenerateRepositorySchemaList. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockSchemaGenerateRepositorySchemaList(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockSchemaGenerateRepositorySchemaList {
	mock := &MockSchemaGenerateRepositorySchemaList{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockSchemaGenerateRepositorySchemaList is an autogenerated mock type for the SchemaGenerateRepositorySchemaList type
type MockSchemaGenerateRepositorySchemaList struct {
	mock.Mock
}

type MockSchemaGenerateRepositorySchemaList_Expecter struct {
	mock *mock.Mock
}

func (_m *MockSchemaGenerateRepositorySchemaList) EXPECT() *MockSchemaGenerateRepositorySchemaList_Expecter {
	return &MockSchemaGenerateRepositorySchemaList_Expecter{mock: &_m.Mock}
}

// Exec provides a mock function for the type MockSchemaGenerateRepositorySchemaList
func (_mock *MockSchemaGenerateRepositorySchemaList) Exec(ctx context.Context, request *dao.SchemaListRequest) ([]*dao.Schema, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for Exec")
	}

	var r0 []*dao.Schema
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *dao.SchemaListRequest) ([]*dao.Schema, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *dao.SchemaListRequest) []*dao.Schema); ok {
		r0 = returnFunc(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*dao.Schema)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *dao.SchemaListRequest) error); ok {
		r1 = returnFunc(ctx, request)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockSchemaGenerateRepositorySchemaList_Exec_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exec'
type MockSchemaGenerateRepositorySchemaList_Exec_Call struct {
	*mock.Call
}

// Exec is a helper method to define mock.On call
//   - ctx context.Context
//   - request *dao.SchemaListRequest
func (_e *MockSchemaGenerateRepositorySchemaList_Expecter) Exec(ctx interface{}, request interface{}) *MockSchemaGenerateRepositorySchemaList_Exec_Call {
	return &MockSchemaGenerateRepositorySchemaList_Exec_Call{Call: _e.mock.On("Exec", ctx, request)}
}

func (_c *MockSchemaGenerateRepositorySchemaList_Exec_Call) Run(run func(ctx context.Context, request *dao.SchemaListRequest)) *MockSchemaGenerateRepositorySchemaList_Exec_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *dao.SchemaListRequest
		if args[1] != nil {
			arg1 = args[1].(*dao.SchemaListRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockSchemaGenerateRepositorySchemaList_Exec_Call) Return(schemas []*dao.Schema, err error) *MockSchemaGenerateRepositorySchemaList_Exec_Call {
	_c.Call.Return(schemas, err)
	return _c
}

func (_c *MockSchemaGenerateRepositorySchemaList_Exec_Call) RunAndReturn(run func(ctx context.Context, request *dao.SchemaListRequest) ([]*dao.Schema, error)) *MockSchemaGenerateRepositorySchemaList_Exec_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockSchemaGenerateRepositorySchemaInsert creates a new instance of MockSchemaGenerateRepositorySchemaInsert. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockSchemaGenerateRepositorySchemaInsert(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockSchemaGenerateRepositorySchemaInsert {
	mock := &MockSchemaGenerateRepositorySchemaInsert{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockSchemaGenerateRepositorySchemaInsert is an autogenerated mock type for the SchemaGenerateRepositorySchemaInsert type
type MockSchemaGenerateRepositorySchemaInsert struct {
	mock.Mock
}

type MockSchemaGenerateRepositorySchemaInsert_Expecter struct {
	mock *mock.Mock
}

func (_m *MockSchemaGenerateRepositorySchemaInsert) EXPECT() *MockSchemaGenerateRepositorySchemaInsert_Expecter {
	return &MockSchemaGenerateRepositorySchemaInsert_Expecter{mock: &_m.Mock}
}

// Exec provides a mock function for the type MockSchemaGenerateRepositorySchemaInsert
func (_mock *MockSchemaGenerateRepositorySchemaInsert) Exec(ctx context.Context, request *dao.SchemaInsertRequest) (*dao.Schema, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for Exec")
	}

	var r0 *dao.Schema
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *dao.SchemaInsertRequest) (*dao.Schema, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *dao.SchemaInsertRequest) *dao.Schema); ok {
		r0 = returnFunc(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dao.Schema)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *dao.SchemaInsertRequest) error); ok {
		r1 = returnFunc(ctx, request)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockSchemaGenerateRepositorySchemaInsert_Exec_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exec'
type MockSchemaGenerateRepositorySchemaInsert_Exec_Call struct {
	*mock.Call
}

// Exec is a helper method to define mock.On call
//   - ctx context.Context
//   - request *dao.SchemaInsertRequest
func (_e *MockSchemaGenerateRepositorySchemaInsert_Expecter) Exec(ctx interface{}, request interface{}) *MockSchemaGenerateRepositorySchemaInsert_Exec_Call {
	return &MockSchemaGenerateRepositorySchemaInsert_Exec_Call{Call: _e.mock.On("Exec", ctx, request)}
}

func (_c *MockSchemaGenerateRepositorySchemaInsert_Exec_Call) Run(run func(ctx context.Context, request *dao.SchemaInsertRequest)) *MockSchemaGenerateRepositorySchemaInsert_Exec_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *dao.SchemaInsertRequest
		if args[1] != nil {
			arg1 = args[1].(*dao.SchemaInsertRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockSchemaGenerateRepositorySchemaInsert_Exec_Call) Return(schema *dao.Schema, err error) *MockSchemaGenerateRepositorySchemaInsert_Exec_Call {
	_c.Call.Return(schema, err)
	return _c
}

func (_c *MockSchemaGenerateRepositorySchemaInsert_Exec_Call) RunAndReturn(run func(ctx context.Context, request *dao.SchemaInsertRequest) (*dao.Schema, error)) *MockSchemaGenerateRepositorySchemaInsert_Exec_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockSchemaGenerateRepositoryProjectSelect creates a new instance of MockSchemaGenerateRepositoryProjectSelect. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockSchemaGenerateRepositoryProjectSelect(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockSchemaGenerateRepositoryProjectSelect {
	mock := &MockSchemaGenerateRepositoryProjectSelect{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockSchemaGenerateRepositoryProjectSelect is an autogenerated mock type for the SchemaGenerateRepositoryProjectSelect type
type MockSchemaGenerateRepositoryProjectSelect struct {
	mock.Mock
}

type MockSchemaGenerateRepositoryProjectSelect_Expecter struct {
	mock *mock.Mock
}

func (_m *MockSchemaGenerateRepositoryProjectSelect) EXPECT() *MockSchemaGenerateRepositoryProjectSelect_Expecter {
	return &MockSchemaGenerateRepositoryProjectSelect_Expecter{mock: &_m.Mock}
}

// Exec provides a mock function for the type MockSchemaGenerateRepositoryProjectSelect
func (_mock *MockSchemaGenerateRepositoryProjectSelect) Exec(ctx context.Context, request *dao.ProjectSelectRequest) (*dao.Project, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for Exec")
	}

	var r0 *dao.Project
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *dao.ProjectSelectRequest) (*dao.Project, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *dao.ProjectSelectRequest) *dao.Project); ok {
		r0 = returnFunc(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dao.Project)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *dao.ProjectSelectRequest) error); ok {
		r1 = returnFunc(ctx, request)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockSchemaGenerateRepositoryProjectSelect_Exec_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exec'
type MockSchemaGenerateRepositoryProjectSelect_Exec_Call struct {
	*mock.Call
}

// Exec is a helper method to define mock.On call
//   - ctx context.Context
//   - request *dao.ProjectSelectRequest
func (_e *MockSchemaGenerateRepositoryProjectSelect_Expecter) Exec(ctx interface{}, request interface{}) *MockSchemaGenerateRepositoryProjectSelect_Exec_Call {
	return &MockSchemaGenerateRepositoryProjectSelect_Exec_Call{Call: _e.mock.On("Exec", ctx, request)}
}

func (_c *MockSchemaGenerateRepositoryProjectSelect_Exec_Call) Run(run func(ctx context.Context, request *dao.ProjectSelectRequest)) *MockSchemaGenerateRepositoryProjectSelect_Exec_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *dao.ProjectSelectRequest
		if args[1] != nil {
			arg1 = args[1].(*dao.ProjectSelectRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockSchemaGenerateRepositoryProjectSelect_Exec_Call) Return(project *dao.Project, err error) *MockSchemaGenerateRepositoryProjectSelect_Exec_Call {
	_c.Call.Return(project, err)
	return _c
}

func (_c *MockSchemaGenerateRepositoryProjectSelect_Exec_Call) RunAndReturn(run func(ctx context.Context, request *dao.ProjectSelectRequest) (*dao.Project, error)) *MockSchemaGenerateRepositoryProjectSelect_Exec_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockSchemaGenerateRepositoryModuleSelect creates a new instance of MockSchemaGenerateRepositoryModuleSelect. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockSchemaGenerateRepositoryModuleSelect(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockSchemaGenerateRepositoryModuleSelect {
	mock := &MockSchemaGenerateRepositoryModuleSelect{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockSchemaGenerateRepositoryModuleSelect is an autogenerated mock type for the SchemaGenerateRepositoryModuleSelect type
type MockSchemaGenerateRepositoryModuleSelect struct {
	mock.Mock
}

type MockSchemaGenerateRepositoryModuleSelect_Expecter struct {
	mock *mock.Mock
}

func (_m *MockSchemaGenerateRepositoryModuleSelect) EXPECT() *MockSchemaGenerateRepositoryModuleSelect_Expecter {
	return &MockSchemaGenerateRepositoryModuleSelect_Expecter{mock: &_m.Mock}
}

// Exec provides a mock function for the type MockSchemaGenerateRepositoryModuleSelect
func (_mock *MockSchemaGenerateRepositoryModuleSelect) Exec(ctx context.Context, request *dao.ModuleSelectRequest) (*dao.Module, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for Exec")
	}

	var r0 *dao.Module
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *dao.ModuleSelectRequest) (*dao.Module, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *dao.ModuleSelectRequest) *dao.Module); ok {
		r0 = returnFunc(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dao.Module)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *dao.ModuleSelectRequest) error); ok {
		r1 = returnFunc(ctx, request)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockSchemaGenerateRepositoryModuleSelect_Exec_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exec'
type MockSchemaGenerateRepositoryModuleSelect_Exec_Call struct {
	*mock.Call
}

// Exec is a helper method to define mock.On call
//   - ctx context.Context
//   - request *dao.ModuleSelectRequest
func (_e *MockSchemaGenerateRepositoryModuleSelect_Expecter) Exec(ctx interface{}, request interface{}) *MockSchemaGenerateRepositoryModuleSelect_Exec_Call {
	return &MockSchemaGenerateRepositoryModuleSelect_Exec_Call{Call: _e.mock.On("Exec", ctx, request)}
}

func (_c *MockSchemaGenerateRepositoryModuleSelect_Exec_Call) Run(run func(ctx context.Context, request *dao.ModuleSelectRequest)) *MockSchemaGenerateRepositoryModuleSelect_Exec_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *dao.ModuleSelectRequest
		if args[1] != nil {
			arg1 = args[1].(*dao.ModuleSelectRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockSchemaGenerateRepositoryModuleSelect_Exec_Call) Return(module *dao.Module, err error) *MockSchemaGenerateRepositoryModuleSelect_Exec_Call {
	_c.Call.Return(module, err)
	return _c
}

func (_c *MockSchemaGenerateRepositoryModuleSelect_Exec_Call) RunAndReturn(run func(ctx context.Context, request *dao.ModuleSelectRequest) (*dao.Module, error)) *MockSchemaGenerateRepositoryModuleSelect_Exec_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockSchemaListVersionsRepository creates a new instance of MockSchemaListVersionsRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockSchemaListVersionsRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockSchemaListVersionsRepository {
	mock := &MockSchemaListVersionsRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockSchemaListVersionsRepository is an autogenerated mock type for the SchemaListVersionsRepository type
type MockSchemaListVersionsRepository struct {
	mock.Mock
}

type MockSchemaListVersionsRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockSchemaListVersionsRepository) EXPECT() *MockSchemaListVersionsRepository_Expecter {
	return &MockSchemaListVersionsRepository_Expecter{mock: &_m.Mock}
}

// Exec provides a mock function for the type MockSchemaListVersionsRepository
func (_mock *MockSchemaListVersionsRepository) Exec(ctx context.Context, request *dao.SchemaListVersionsRequest) ([]*dao.SchemaVersion, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for Exec")
	}

	var r0 []*dao.SchemaVersion
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *dao.SchemaListVersionsRequest) ([]*dao.SchemaVersion, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *dao.SchemaListVersionsRequest) []*dao.SchemaVersion); ok {
		r0 = returnFunc(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*dao.SchemaVersion)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *dao.SchemaListVersionsRequest) error); ok {
		r1 = returnFunc(ctx, request)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockSchemaListVersionsRepository_Exec_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exec'
type MockSchemaListVersionsRepository_Exec_Call struct {
	*mock.Call
}

// Exec is a helper method to define mock.On call
//   - ctx context.Context
//   - request *dao.SchemaListVersionsRequest
func (_e *MockSchemaListVersionsRepository_Expecter) Exec(ctx interface{}, request interface{}) *MockSchemaListVersionsRepository_Exec_Call {
	return &MockSchemaListVersionsRepository_Exec_Call{Call: _e.mock.On("Exec", ctx, request)}
}

func (_c *MockSchemaListVersionsRepository_Exec_Call) Run(run func(ctx context.Context, request *dao.SchemaListVersionsRequest)) *MockSchemaListVersionsRepository_Exec_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *dao.SchemaListVersionsRequest
		if args[1] != nil {
			arg1 = args[1].(*dao.SchemaListVersionsRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockSchemaListVersionsRepository_Exec_Call) Return(schemaVersions []*dao.SchemaVersion, err error) *MockSchemaListVersionsRepository_Exec_Call {
	_c.Call.Return(schemaVersions, err)
	return _c
}

func (_c *MockSchemaListVersionsRepository_Exec_Call) RunAndReturn(run func(ctx context.Context, request *dao.SchemaListVersionsRequest) ([]*dao.SchemaVersion, error)) *MockSchemaListVersionsRepository_Exec_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockSchemaListVersionsRepositoryProjectSelect creates a new instance of MockSchemaListVersionsRepositoryProjectSelect. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockSchemaListVersionsRepositoryProjectSelect(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockSchemaListVersionsRepositoryProjectSelect {
	mock := &MockSchemaListVersionsRepositoryProjectSelect{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockSchemaListVersionsRepositoryProjectSelect is an autogenerated mock type for the SchemaListVersionsRepositoryProjectSelect type
type MockSchemaListVersionsRepositoryProjectSelect struct {
	mock.Mock
}

type MockSchemaListVersionsRepositoryProjectSelect_Expecter struct {
	mock *mock.Mock
}

func (_m *MockSchemaListVersionsRepositoryProjectSelect) EXPECT() *MockSchemaListVersionsRepositoryProjectSelect_Expecter {
	return &MockSchemaListVersionsRepositoryProjectSelect_Expecter{mock: &_m.Mock}
}

// Exec provides a mock function for the type MockSchemaListVersionsRepositoryProjectSelect
func (_mock *MockSchemaListVersionsRepositoryProjectSelect) Exec(ctx context.Context, request *dao.ProjectSelectRequest) (*dao.Project, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for Exec")
	}

	var r0 *dao.Project
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *dao.ProjectSelectRequest) (*dao.Project, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *dao.ProjectSelectRequest) *dao.Project); ok {
		r0 = returnFunc(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dao.Project)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *dao.ProjectSelectRequest) error); ok {
		r1 = returnFunc(ctx, request)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockSchemaListVersionsRepositoryProjectSelect_Exec_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exec'
type MockSchemaListVersionsRepositoryProjectSelect_Exec_Call struct {
	*mock.Call
}

// Exec is a helper method to define mock.On call
//   - ctx context.Context
//   - request *dao.ProjectSelectRequest
func (_e *MockSchemaListVersionsRepositoryProjectSelect_Expecter) Exec(ctx interface{}, request interface{}) *MockSchemaListVersionsRepositoryProjectSelect_Exec_Call {
	return &MockSchemaListVersionsRepositoryProjectSelect_Exec_Call{Call: _e.mock.On("Exec", ctx, request)}
}

func (_c *MockSchemaListVersionsRepositoryProjectSelect_Exec_Call) Run(run func(ctx context.Context, request *dao.ProjectSelectRequest)) *MockSchemaListVersionsRepositoryProjectSelect_Exec_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *dao.ProjectSelectRequest
		if args[1] != nil {
			arg1 = args[1].(*dao.ProjectSelectRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockSchemaListVersionsRepositoryProjectSelect_Exec_Call) Return(project *dao.Project, err error) *MockSchemaListVersionsRepositoryProjectSelect_Exec_Call {
	_c.Call.Return(project, err)
	return _c
}

func (_c *MockSchemaListVersionsRepositoryProjectSelect_Exec_Call) RunAndReturn(run func(ctx context.Context, request *dao.ProjectSelectRequest) (*dao.Project, error)) *MockSchemaListVersionsRepositoryProjectSelect_Exec_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockSchemaRewriteRepository creates a new instance of MockSchemaRewriteRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockSchemaRewriteRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockSchemaRewriteRepository {
	mock := &MockSchemaRewriteRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockSchemaRewriteRepository is an autogenerated mock type for the SchemaRewriteRepository type
type MockSchemaRewriteRepository struct {
	mock.Mock
}

type MockSchemaRewriteRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockSchemaRewriteRepository) EXPECT() *MockSchemaRewriteRepository_Expecter {
	return &MockSchemaRewriteRepository_Expecter{mock: &_m.Mock}
}

// Exec provides a mock function for the type MockSchemaRewriteRepository
func (_mock *MockSchemaRewriteRepository) Exec(ctx context.Context, request *dao.SchemaUpdateRequest) (*dao.Schema, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for Exec")
	}

	var r0 *dao.Schema
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *dao.SchemaUpdateRequest) (*dao.Schema, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *dao.SchemaUpdateRequest) *dao.Schema); ok {
		r0 = returnFunc(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dao.Schema)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *dao.SchemaUpdateRequest) error); ok {
		r1 = returnFunc(ctx, request)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockSchemaRewriteRepository_Exec_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exec'
type MockSchemaRewriteRepository_Exec_Call struct {
	*mock.Call
}

// Exec is a helper method to define mock.On call
//   - ctx context.Context
//   - request *dao.SchemaUpdateRequest
func (_e *MockSchemaRewriteRepository_Expecter) Exec(ctx interface{}, request interface{}) *MockSchemaRewriteRepository_Exec_Call {
	return &MockSchemaRewriteRepository_Exec_Call{Call: _e.mock.On("Exec", ctx, request)}
}

func (_c *MockSchemaRewriteRepository_Exec_Call) Run(run func(ctx context.Context, request *dao.SchemaUpdateRequest)) *MockSchemaRewriteRepository_Exec_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *dao.SchemaUpdateRequest
		if args[1] != nil {
			arg1 = args[1].(*dao.SchemaUpdateRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockSchemaRewriteRepository_Exec_Call) Return(schema *dao.Schema, err error) *MockSchemaRewriteRepository_Exec_Call {
	_c.Call.Return(schema, err)
	return _c
}

func (_c *MockSchemaRewriteRepository_Exec_Call) RunAndReturn(run func(ctx context.Context, request *dao.SchemaUpdateRequest) (*dao.Schema, error)) *MockSchemaRewriteRepository_Exec_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockSchemaRewriteRepositoryProjectSelect creates a new instance of MockSchemaRewriteRepositoryProjectSelect. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockSchemaRewriteRepositoryProjectSelect(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockSchemaRewriteRepositoryProjectSelect {
	mock := &MockSchemaRewriteRepositoryProjectSelect{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockSchemaRewriteRepositoryProjectSelect is an autogenerated mock type for the SchemaRewriteRepositoryProjectSelect type
type MockSchemaRewriteRepositoryProjectSelect struct {
	mock.Mock
}

type MockSchemaRewriteRepositoryProjectSelect_Expecter struct {
	mock *mock.Mock
}

func (_m *MockSchemaRewriteRepositoryProjectSelect) EXPECT() *MockSchemaRewriteRepositoryProjectSelect_Expecter {
	return &MockSchemaRewriteRepositoryProjectSelect_Expecter{mock: &_m.Mock}
}

// Exec provides a mock function for the type MockSchemaRewriteRepositoryProjectSelect
func (_mock *MockSchemaRewriteRepositoryProjectSelect) Exec(ctx context.Context, request *dao.ProjectSelectRequest) (*dao.Project, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for Exec")
	}

	var r0 *dao.Project
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *dao.ProjectSelectRequest) (*dao.Project, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *dao.ProjectSelectRequest) *dao.Project); ok {
		r0 = returnFunc(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dao.Project)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *dao.ProjectSelectRequest) error); ok {
		r1 = returnFunc(ctx, request)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockSchemaRewriteRepositoryProjectSelect_Exec_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exec'
type MockSchemaRewriteRepositoryProjectSelect_Exec_Call struct {
	*mock.Call
}

// Exec is a helper method to define mock.On call
//   - ctx context.Context
//   - request *dao.ProjectSelectRequest
func (_e *MockSchemaRewriteRepositoryProjectSelect_Expecter) Exec(ctx interface{}, request interface{}) *MockSchemaRewriteRepositoryProjectSelect_Exec_Call {
	return &MockSchemaRewriteRepositoryProjectSelect_Exec_Call{Call: _e.mock.On("Exec", ctx, request)}
}

func (_c *MockSchemaRewriteRepositoryProjectSelect_Exec_Call) Run(run func(ctx context.Context, request *dao.ProjectSelectRequest)) *MockSchemaRewriteRepositoryProjectSelect_Exec_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *dao.ProjectSelectRequest
		if args[1] != nil {
			arg1 = args[1].(*dao.ProjectSelectRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockSchemaRewriteRepositoryProjectSelect_Exec_Call) Return(project *dao.Project, err error) *MockSchemaRewriteRepositoryProjectSelect_Exec_Call {
	_c.Call.Return(project, err)
	return _c
}

func (_c *MockSchemaRewriteRepositoryProjectSelect_Exec_Call) RunAndReturn(run func(ctx context.Context, request *dao.ProjectSelectRequest) (*dao.Project, error)) *MockSchemaRewriteRepositoryProjectSelect_Exec_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockSchemaRewriteRepositorySchemaSelect creates a new instance of MockSchemaRewriteRepositorySchemaSelect. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockSchemaRewriteRepositorySchemaSelect(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockSchemaRewriteRepositorySchemaSelect {
	mock := &MockSchemaRewriteRepositorySchemaSelect{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockSchemaRewriteRepositorySchemaSelect is an autogenerated mock type for the SchemaRewriteRepositorySchemaSelect type
type MockSchemaRewriteRepositorySchemaSelect struct {
	mock.Mock
}

type MockSchemaRewriteRepositorySchemaSelect_Expecter struct {
	mock *mock.Mock
}

func (_m *MockSchemaRewriteRepositorySchemaSelect) EXPECT() *MockSchemaRewriteRepositorySchemaSelect_Expecter {
	return &MockSchemaRewriteRepositorySchemaSelect_Expecter{mock: &_m.Mock}
}

// Exec provides a mock function for the type MockSchemaRewriteRepositorySchemaSelect
func (_mock *MockSchemaRewriteRepositorySchemaSelect) Exec(ctx context.Context, request *dao.SchemaSelectRequest) (*dao.Schema, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for Exec")
	}

	var r0 *dao.Schema
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *dao.SchemaSelectRequest) (*dao.Schema, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *dao.SchemaSelectRequest) *dao.Schema); ok {
		r0 = returnFunc(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dao.Schema)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *dao.SchemaSelectRequest) error); ok {
		r1 = returnFunc(ctx, request)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockSchemaRewriteRepositorySchemaSelect_Exec_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exec'
type MockSchemaRewriteRepositorySchemaSelect_Exec_Call struct {
	*mock.Call
}

// Exec is a helper method to define mock.On call
//   - ctx context.Context
//   - request *dao.SchemaSelectRequest
func (_e *MockSchemaRewriteRepositorySchemaSelect_Expecter) Exec(ctx interface{}, request interface{}) *MockSchemaRewriteRepositorySchemaSelect_Exec_Call {
	return &MockSchemaRewriteRepositorySchemaSelect_Exec_Call{Call: _e.mock.On("Exec", ctx, request)}
}

func (_c *MockSchemaRewriteRepositorySchemaSelect_Exec_Call) Run(run func(ctx context.Context, request *dao.SchemaSelectRequest)) *MockSchemaRewriteRepositorySchemaSelect_Exec_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *dao.SchemaSelectRequest
		if args[1] != nil {
			arg1 = args[1].(*dao.SchemaSelectRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockSchemaRewriteRepositorySchemaSelect_Exec_Call) Return(schema *dao.Schema, err error) *MockSchemaRewriteRepositorySchemaSelect_Exec_Call {
	_c.Call.Return(schema, err)
	return _c
}

func (_c *MockSchemaRewriteRepositorySchemaSelect_Exec_Call) RunAndReturn(run func(ctx context.Context, request *dao.SchemaSelectRequest) (*dao.Schema, error)) *MockSchemaRewriteRepositorySchemaSelect_Exec_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockSchemaSelectRepository creates a new instance of MockSchemaSelectRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockSchemaSelectRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockSchemaSelectRepository {
	mock := &MockSchemaSelectRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockSchemaSelectRepository is an autogenerated mock type for the SchemaSelectRepository type
type MockSchemaSelectRepository struct {
	mock.Mock
}

type MockSchemaSelectRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockSchemaSelectRepository) EXPECT() *MockSchemaSelectRepository_Expecter {
	return &MockSchemaSelectRepository_Expecter{mock: &_m.Mock}
}

// Exec provides a mock function for the type MockSchemaSelectRepository
func (_mock *MockSchemaSelectRepository) Exec(ctx context.Context, request *dao.SchemaSelectRequest) (*dao.Schema, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for Exec")
	}

	var r0 *dao.Schema
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *dao.SchemaSelectRequest) (*dao.Schema, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *dao.SchemaSelectRequest) *dao.Schema); ok {
		r0 = returnFunc(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dao.Schema)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *dao.SchemaSelectRequest) error); ok {
		r1 = returnFunc(ctx, request)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockSchemaSelectRepository_Exec_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exec'
type MockSchemaSelectRepository_Exec_Call struct {
	*mock.Call
}

// Exec is a helper method to define mock.On call
//   - ctx context.Context
//   - request *dao.SchemaSelectRequest
func (_e *MockSchemaSelectRepository_Expecter) Exec(ctx interface{}, request interface{}) *MockSchemaSelectRepository_Exec_Call {
	return &MockSchemaSelectRepository_Exec_Call{Call: _e.mock.On("Exec", ctx, request)}
}

func (_c *MockSchemaSelectRepository_Exec_Call) Run(run func(ctx context.Context, request *dao.SchemaSelectRequest)) *MockSchemaSelectRepository_Exec_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *dao.SchemaSelectRequest
		if args[1] != nil {
			arg1 = args[1].(*dao.SchemaSelectRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockSchemaSelectRepository_Exec_Call) Return(schema *dao.Schema, err error) *MockSchemaSelectRepository_Exec_Call {
	_c.Call.Return(schema, err)
	return _c
}

func (_c *MockSchemaSelectRepository_Exec_Call) RunAndReturn(run func(ctx context.Context, request *dao.SchemaSelectRequest) (*dao.Schema, error)) *MockSchemaSelectRepository_Exec_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockSchemaSelectRepositoryProjectSelect creates a new instance of MockSchemaSelectRepositoryProjectSelect. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockSchemaSelectRepositoryProjectSelect(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockSchemaSelectRepositoryProjectSelect {
	mock := &MockSchemaSelectRepositoryProjectSelect{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockSchemaSelectRepositoryProjectSelect is an autogenerated mock type for the SchemaSelectRepositoryProjectSelect type
type MockSchemaSelectRepositoryProjectSelect struct {
	mock.Mock
}

type MockSchemaSelectRepositoryProjectSelect_Expecter struct {
	mock *mock.Mock
}

func (_m *MockSchemaSelectRepositoryProjectSelect) EXPECT() *MockSchemaSelectRepositoryProjectSelect_Expecter {
	return &MockSchemaSelectRepositoryProjectSelect_Expecter{mock: &_m.Mock}
}

// Exec provides a mock function for the type MockSchemaSelectRepositoryProjectSelect
func (_mock *MockSchemaSelectRepositoryProjectSelect) Exec(ctx context.Context, request *dao.ProjectSelectRequest) (*dao.Project, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for Exec")
	}

	var r0 *dao.Project
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *dao.ProjectSelectRequest) (*dao.Project, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *dao.ProjectSelectRequest) *dao.Project); ok {
		r0 = returnFunc(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dao.Project)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *dao.ProjectSelectRequest) error); ok {
		r1 = returnFunc(ctx, request)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockSchemaSelectRepositoryProjectSelect_Exec_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exec'
type MockSchemaSelectRepositoryProjectSelect_Exec_Call struct {
	*mock.Call
}

// Exec is a helper method to define mock.On call
//   - ctx context.Context
//   - request *dao.ProjectSelectRequest
func (_e *MockSchemaSelectRepositoryProjectSelect_Expecter) Exec(ctx interface{}, request interface{}) *MockSchemaSelectRepositoryProjectSelect_Exec_Call {
	return &MockSchemaSelectRepositoryProjectSelect_Exec_Call{Call: _e.mock.On("Exec", ctx, request)}
}

func (_c *MockSchemaSelectRepositoryProjectSelect_Exec_Call) Run(run func(ctx context.Context, request *dao.ProjectSelectRequest)) *MockSchemaSelectRepositoryProjectSelect_Exec_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *dao.ProjectSelectRequest
		if args[1] != nil {
			arg1 = args[1].(*dao.ProjectSelectRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockSchemaSelectRepositoryProjectSelect_Exec_Call) Return(project *dao.Project, err error) *MockSchemaSelectRepositoryProjectSelect_Exec_Call {
	_c.Call.Return(project, err)
	return _c
}

func (_c *MockSchemaSelectRepositoryProjectSelect_Exec_Call) RunAndReturn(run func(ctx context.Context, request *dao.ProjectSelectRequest) (*dao.Project, error)) *MockSchemaSelectRepositoryProjectSelect_Exec_Call {
	_c.Call.Return(run)
	return _c
}

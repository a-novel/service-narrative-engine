// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package handlersmocks

import (
	"context"

	"github.com/a-novel/service-json-keys/v2/pkg"
	"github.com/a-novel/service-narrative-engine/internal/services"
	mock "github.com/stretchr/testify/mock"
	"google.golang.org/grpc"
)

// NewMockHealthApiJsonkeys creates a new instance of MockHealthApiJsonkeys. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockHealthApiJsonkeys(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockHealthApiJsonkeys {
	mock := &MockHealthApiJsonkeys{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockHealthApiJsonkeys is an autogenerated mock type for the HealthApiJsonkeys type
type MockHealthApiJsonkeys struct {
	mock.Mock
}

type MockHealthApiJsonkeys_Expecter struct {
	mock *mock.Mock
}

func (_m *MockHealthApiJsonkeys) EXPECT() *MockHealthApiJsonkeys_Expecter {
	return &MockHealthApiJsonkeys_Expecter{mock: &_m.Mock}
}

// Status provides a mock function for the type MockHealthApiJsonkeys
func (_mock *MockHealthApiJsonkeys) Status(ctx context.Context, req *pkg.StatusRequest, opts ...grpc.CallOption) (*pkg.StatusResponse, error) {
	var tmpRet mock.Arguments
	if len(opts) > 0 {
		tmpRet = _mock.Called(ctx, req, opts)
	} else {
		tmpRet = _mock.Called(ctx, req)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for Status")
	}

	var r0 *pkg.StatusResponse
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *pkg.StatusRequest, ...grpc.CallOption) (*pkg.StatusResponse, error)); ok {
		return returnFunc(ctx, req, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *pkg.StatusRequest, ...grpc.CallOption) *pkg.StatusResponse); ok {
		r0 = returnFunc(ctx, req, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pkg.StatusResponse)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *pkg.StatusRequest, ...grpc.CallOption) error); ok {
		r1 = returnFunc(ctx, req, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockHealthApiJsonkeys_Status_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Status'
type MockHealthApiJsonkeys_Status_Call struct {
	*mock.Call
}

// Status is a helper method to define mock.On call
//   - ctx context.Context
//   - req *pkg.StatusRequest
//   - opts ...grpc.CallOption
func (_e *MockHealthApiJsonkeys_Expecter) Status(ctx interface{}, req interface{}, opts ...interface{}) *MockHealthApiJsonkeys_Status_Call {
	return &MockHealthApiJsonkeys_Status_Call{Call: _e.mock.On("Status",
		append([]interface{}{ctx, req}, opts...)...)}
}

func (_c *MockHealthApiJsonkeys_Status_Call) Run(run func(ctx context.Context, req *pkg.StatusRequest, opts ...grpc.CallOption)) *MockHealthApiJsonkeys_Status_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *pkg.StatusRequest
		if args[1] != nil {
			arg1 = args[1].(*pkg.StatusRequest)
		}
		var arg2 []grpc.CallOption
		var variadicArgs []grpc.CallOption
		if len(args) > 2 {
			variadicArgs = args[2].([]grpc.CallOption)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockHealthApiJsonkeys_Status_Call) Return(v *pkg.StatusResponse, err error) *MockHealthApiJsonkeys_Status_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *MockHealthApiJsonkeys_Status_Call) RunAndReturn(run func(ctx context.Context, req *pkg.StatusRequest, opts ...grpc.CallOption) (*pkg.StatusResponse, error)) *MockHealthApiJsonkeys_Status_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockModuleListVersionsService creates a new instance of MockModuleListVersionsService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockModuleListVersionsService(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockModuleListVersionsService {
	mock := &MockModuleListVersionsService{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockModuleListVersionsService is an autogenerated mock type for the ModuleListVersionsService type
type MockModuleListVersionsService struct {
	mock.Mock
}

type MockModuleListVersionsService_Expecter struct {
	mock *mock.Mock
}

func (_m *MockModuleListVersionsService) EXPECT() *MockModuleListVersionsService_Expecter {
	return &MockModuleListVersionsService_Expecter{mock: &_m.Mock}
}

// Exec provides a mock function for the type MockModuleListVersionsService
func (_mock *MockModuleListVersionsService) Exec(ctx context.Context, request *services.ModuleListVersionsRequest) ([]*services.ModuleVersion, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for Exec")
	}

	var r0 []*services.ModuleVersion
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *services.ModuleListVersionsRequest) ([]*services.ModuleVersion, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *services.ModuleListVersionsRequest) []*services.ModuleVersion); ok {
		r0 = returnFunc(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*services.ModuleVersion)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *services.ModuleListVersionsRequest) error); ok {
		r1 = returnFunc(ctx, request)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockModuleListVersionsService_Exec_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exec'
type MockModuleListVersionsService_Exec_Call struct {
	*mock.Call
}

// Exec is a helper method to define mock.On call
//   - ctx context.Context
//   - request *services.ModuleListVersionsRequest
func (_e *MockModuleListVersionsService_Expecter) Exec(ctx interface{}, request interface{}) *MockModuleListVersionsService_Exec_Call {
	return &MockModuleListVersionsService_Exec_Call{Call: _e.mock.On("Exec", ctx, request)}
}

func (_c *MockModuleListVersionsService_Exec_Call) Run(run func(ctx context.Context, request *services.ModuleListVersionsRequest)) *MockModuleListVersionsService_Exec_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *services.ModuleListVersionsRequest
		if args[1] != nil {
			arg1 = args[1].(*services.ModuleListVersionsRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockModuleListVersionsService_Exec_Call) Return(moduleVersions []*services.ModuleVersion, err error) *MockModuleListVersionsService_Exec_Call {
	_c.Call.Return(moduleVersions, err)
	return _c
}

func (_c *MockModuleListVersionsService_Exec_Call) RunAndReturn(run func(ctx context.Context, request *services.ModuleListVersionsRequest) ([]*services.ModuleVersion, error)) *MockModuleListVersionsService_Exec_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockModuleSelectService creates a new instance of MockModuleSelectService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockModuleSelectService(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockModuleSelectService {
	mock := &MockModuleSelectService{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockModuleSelectService is an autogenerated mock type for the ModuleSelectService type
type MockModuleSelectService struct {
	mock.Mock
}

type MockModuleSelectService_Expecter struct {
	mock *mock.Mock
}

func (_m *MockModuleSelectService) EXPECT() *MockModuleSelectService_Expecter {
	return &MockModuleSelectService_Expecter{mock: &_m.Mock}
}

// Exec provides a mock function for the type MockModuleSelectService
func (_mock *MockModuleSelectService) Exec(ctx context.Context, request *services.ModuleSelectRequest) (*services.Module, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for Exec")
	}

	var r0 *services.Module
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *services.ModuleSelectRequest) (*services.Module, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *services.ModuleSelectRequest) *services.Module); ok {
		r0 = returnFunc(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*services.Module)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *services.ModuleSelectRequest) error); ok {
		r1 = returnFunc(ctx, request)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockModuleSelectService_Exec_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exec'
type MockModuleSelectService_Exec_Call struct {
	*mock.Call
}

// Exec is a helper method to define mock.On call
//   - ctx context.Context
//   - request *services.ModuleSelectRequest
func (_e *MockModuleSelectService_Expecter) Exec(ctx interface{}, request interface{}) *MockModuleSelectService_Exec_Call {
	return &MockModuleSelectService_Exec_Call{Call: _e.mock.On("Exec", ctx, request)}
}

func (_c *MockModuleSelectService_Exec_Call) Run(run func(ctx context.Context, request *services.ModuleSelectRequest)) *MockModuleSelectService_Exec_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *services.ModuleSelectRequest
		if args[1] != nil {
			arg1 = args[1].(*services.ModuleSelectRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockModuleSelectService_Exec_Call) Return(module *services.Module, err error) *MockModuleSelectService_Exec_Call {
	_c.Call.Return(module, err)
	return _c
}

func (_c *MockModuleSelectService_Exec_Call) RunAndReturn(run func(ctx context.Context, request *services.ModuleSelectRequest) (*services.Module, error)) *MockModuleSelectService_Exec_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockProjectDeleteService creates a new instance of MockProjectDeleteService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockProjectDeleteService(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockProjectDeleteService {
	mock := &MockProjectDeleteService{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockProjectDeleteService is an autogenerated mock type for the ProjectDeleteService type
type MockProjectDeleteService struct {
	mock.Mock
}

type MockProjectDeleteService_Expecter struct {
	mock *mock.Mock
}

func (_m *MockProjectDeleteService) EXPECT() *MockProjectDeleteService_Expecter {
	return &MockProjectDeleteService_Expecter{mock: &_m.Mock}
}

// Exec provides a mock function for the type MockProjectDeleteService
func (_mock *MockProjectDeleteService) Exec(ctx context.Context, request *services.ProjectDeleteRequest) (*services.Project, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for Exec")
	}

	var r0 *services.Project
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *services.ProjectDeleteRequest) (*services.Project, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *services.ProjectDeleteRequest) *services.Project); ok {
		r0 = returnFunc(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*services.Project)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *services.ProjectDeleteRequest) error); ok {
		r1 = returnFunc(ctx, request)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockProjectDeleteService_Exec_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exec'
type MockProjectDeleteService_Exec_Call struct {
	*mock.Call
}

// Exec is a helper method to define mock.On call
//   - ctx context.Context
//   - request *services.ProjectDeleteRequest
func (_e *MockProjectDeleteService_Expecter) Exec(ctx interface{}, request interface{}) *MockProjectDeleteService_Exec_Call {
	return &MockProjectDeleteService_Exec_Call{Call: _e.mock.On("Exec", ctx, request)}
}

func (_c *MockProjectDeleteService_Exec_Call) Run(run func(ctx context.Context, request *services.ProjectDeleteRequest)) *MockProjectDeleteService_Exec_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *services.ProjectDeleteRequest
		if args[1] != nil {
			arg1 = args[1].(*services.ProjectDeleteRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockProjectDeleteService_Exec_Call) Return(project *services.Project, err error) *MockProjectDeleteService_Exec_Call {
	_c.Call.Return(project, err)
	return _c
}

func (_c *MockProjectDeleteService_Exec_Call) RunAndReturn(run func(ctx context.Context, request *services.ProjectDeleteRequest) (*services.Project, error)) *MockProjectDeleteService_Exec_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockProjectInitService creates a new instance of MockProjectInitService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockProjectInitService(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockProjectInitService {
	mock := &MockProjectInitService{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockProjectInitService is an autogenerated mock type for the ProjectInitService type
type MockProjectInitService struct {
	mock.Mock
}

type MockProjectInitService_Expecter struct {
	mock *mock.Mock
}

func (_m *MockProjectInitService) EXPECT() *MockProjectInitService_Expecter {
	return &MockProjectInitService_Expecter{mock: &_m.Mock}
}

// Exec provides a mock function for the type MockProjectInitService
func (_mock *MockProjectInitService) Exec(ctx context.Context, request *services.ProjectInitRequest) (*services.Project, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for Exec")
	}

	var r0 *services.Project
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *services.ProjectInitRequest) (*services.Project, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *services.ProjectInitRequest) *services.Project); ok {
		r0 = returnFunc(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*services.Project)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *services.ProjectInitRequest) error); ok {
		r1 = returnFunc(ctx, request)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockProjectInitService_Exec_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exec'
type MockProjectInitService_Exec_Call struct {
	*mock.Call
}

// Exec is a helper method to define mock.On call
//   - ctx context.Context
//   - request *services.ProjectInitRequest
func (_e *MockProjectInitService_Expecter) Exec(ctx interface{}, request interface{}) *MockProjectInitService_Exec_Call {
	return &MockProjectInitService_Exec_Call{Call: _e.mock.On("Exec", ctx, request)}
}

func (_c *MockProjectInitService_Exec_Call) Run(run func(ctx context.Context, request *services.ProjectInitRequest)) *MockProjectInitService_Exec_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *services.ProjectInitRequest
		if args[1] != nil {
			arg1 = args[1].(*services.ProjectInitRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockProjectInitService_Exec_Call) Return(project *services.Project, err error) *MockProjectInitService_Exec_Call {
	_c.Call.Return(project, err)
	return _c
}

func (_c *MockProjectInitService_Exec_Call) RunAndReturn(run func(ctx context.Context, request *services.ProjectInitRequest) (*services.Project, error)) *MockProjectInitService_Exec_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockProjectListService creates a new instance of MockProjectListService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockProjectListService(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockProjectListService {
	mock := &MockProjectListService{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockProjectListService is an autogenerated mock type for the ProjectListService type
type MockProjectListService struct {
	mock.Mock
}

type MockProjectListService_Expecter struct {
	mock *mock.Mock
}

func (_m *MockProjectListService) EXPECT() *MockProjectListService_Expecter {
	return &MockProjectListService_Expecter{mock: &_m.Mock}
}

// Exec provides a mock function for the type MockProjectListService
func (_mock *MockProjectListService) Exec(ctx context.Context, request *services.ProjectListRequest) ([]*services.Project, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for Exec")
	}

	var r0 []*services.Project
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *services.ProjectListRequest) ([]*services.Project, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *services.ProjectListRequest) []*services.Project); ok {
		r0 = returnFunc(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*services.Project)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *services.ProjectListRequest) error); ok {
		r1 = returnFunc(ctx, request)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockProjectListService_Exec_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exec'
type MockProjectListService_Exec_Call struct {
	*mock.Call
}

// Exec is a helper method to define mock.On call
//   - ctx context.Context
//   - request *services.ProjectListRequest
func (_e *MockProjectListService_Expecter) Exec(ctx interface{}, request interface{}) *MockProjectListService_Exec_Call {
	return &MockProjectListService_Exec_Call{Call: _e.mock.On("Exec", ctx, request)}
}

func (_c *MockProjectListService_Exec_Call) Run(run func(ctx context.Context, request *services.ProjectListRequest)) *MockProjectListService_Exec_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *services.ProjectListRequest
		if args[1] != nil {
			arg1 = args[1].(*services.ProjectListRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockProjectListService_Exec_Call) Return(projects []*services.Project, err error) *MockProjectListService_Exec_Call {
	_c.Call.Return(projects, err)
	return _c
}

func (_c *MockProjectListService_Exec_Call) RunAndReturn(run func(ctx context.Context, request *services.ProjectListRequest) ([]*services.Project, error)) *MockProjectListService_Exec_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockProjectUpdateService creates a new instance of MockProjectUpdateService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockProjectUpdateService(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockProjectUpdateService {
	mock := &MockProjectUpdateService{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockProjectUpdateService is an autogenerated mock type for the ProjectUpdateService type
type MockProjectUpdateService struct {
	mock.Mock
}

type MockProjectUpdateService_Expecter struct {
	mock *mock.Mock
}

func (_m *MockProjectUpdateService) EXPECT() *MockProjectUpdateService_Expecter {
	return &MockProjectUpdateService_Expecter{mock: &_m.Mock}
}

// Exec provides a mock function for the type MockProjectUpdateService
func (_mock *MockProjectUpdateService) Exec(ctx context.Context, request *services.ProjectUpdateRequest) (*services.Project, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for Exec")
	}

	var r0 *services.Project
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *services.ProjectUpdateRequest) (*services.Project, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *services.ProjectUpdateRequest) *services.Project); ok {
		r0 = returnFunc(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*services.Project)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *services.ProjectUpdateRequest) error); ok {
		r1 = returnFunc(ctx, request)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockProjectUpdateService_Exec_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exec'
type MockProjectUpdateService_Exec_Call struct {
	*mock.Call
}

// Exec is a helper method to define mock.On call
//   - ctx context.Context
//   - request *services.ProjectUpdateRequest
func (_e *MockProjectUpdateService_Expecter) Exec(ctx interface{}, request interface{}) *MockProjectUpdateService_Exec_Call {
	return &MockProjectUpdateService_Exec_Call{Call: _e.mock.On("Exec", ctx, request)}
}

func (_c *MockProjectUpdateService_Exec_Call) Run(run func(ctx context.Context, request *services.ProjectUpdateRequest)) *MockProjectUpdateService_Exec_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *services.ProjectUpdateRequest
		if args[1] != nil {
			arg1 = args[1].(*services.ProjectUpdateRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockProjectUpdateService_Exec_Call) Return(project *services.Project, err error) *MockProjectUpdateService_Exec_Call {
	_c.Call.Return(project, err)
	return _c
}

func (_c *MockProjectUpdateService_Exec_Call) RunAndReturn(run func(ctx context.Context, request *services.ProjectUpdateRequest) (*services.Project, error)) *MockProjectUpdateService_Exec_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockSchemaCreateService creates a new instance of MockSchemaCreateService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockSchemaCreateService(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockSchemaCreateService {
	mock := &MockSchemaCreateService{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockSchemaCreateService is an autogenerated mock type for the SchemaCreateService type
type MockSchemaCreateService struct {
	mock.Mock
}

type MockSchemaCreateService_Expecter struct {
	mock *mock.Mock
}

func (_m *MockSchemaCreateService) EXPECT() *MockSchemaCreateService_Expecter {
	return &MockSchemaCreateService_Expecter{mock: &_m.Mock}
}

// Exec provides a mock function for the type MockSchemaCreateService
func (_mock *MockSchemaCreateService) Exec(ctx context.Context, request *services.SchemaCreateRequest) (*services.Schema, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for Exec")
	}

	var r0 *services.Schema
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *services.SchemaCreateRequest) (*services.Schema, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *services.SchemaCreateRequest) *services.Schema); ok {
		r0 = returnFunc(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*services.Schema)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *services.SchemaCreateRequest) error); ok {
		r1 = returnFunc(ctx, request)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockSchemaCreateService_Exec_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exec'
type MockSchemaCreateService_Exec_Call struct {
	*mock.Call
}

// Exec is a helper method to define mock.On call
//   - ctx context.Context
//   - request *services.SchemaCreateRequest
func (_e *MockSchemaCreateService_Expecter) Exec(ctx interface{}, request interface{}) *MockSchemaCreateService_Exec_Call {
	return &MockSchemaCreateService_Exec_Call{Call: _e.mock.On("Exec", ctx, request)}
}

func (_c *MockSchemaCreateService_Exec_Call) Run(run func(ctx context.Context, request *services.SchemaCreateRequest)) *MockSchemaCreateService_Exec_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *services.SchemaCreateRequest
		if args[1] != nil {
			arg1 = args[1].(*services.SchemaCreateRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockSchemaCreateService_Exec_Call) Return(schema *services.Schema, err error) *MockSchemaCreateService_Exec_Call {
	_c.Call.Return(schema, err)
	return _c
}

func (_c *MockSchemaCreateService_Exec_Call) RunAndReturn(run func(ctx context.Context, request *services.SchemaCreateRequest) (*services.Schema, error)) *MockSchemaCreateService_Exec_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockSchemaGenerateService creates a new instance of MockSchemaGenerateService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockSchemaGenerateService(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockSchemaGenerateService {
	mock := &MockSchemaGenerateService{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockSchemaGenerateService is an autogenerated mock type for the SchemaGenerateService type
type MockSchemaGenerateService struct {
	mock.Mock
}

type MockSchemaGenerateService_Expecter struct {
	mock *mock.Mock
}

func (_m *MockSchemaGenerateService) EXPECT() *MockSchemaGenerateService_Expecter {
	return &MockSchemaGenerateService_Expecter{mock: &_m.Mock}
}

// Exec provides a mock function for the type MockSchemaGenerateService
func (_mock *MockSchemaGenerateService) Exec(ctx context.Context, request *services.SchemaGenerateRequest) (*services.Schema, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for Exec")
	}

	var r0 *services.Schema
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *services.SchemaGenerateRequest) (*services.Schema, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *services.SchemaGenerateRequest) *services.Schema); ok {
		r0 = returnFunc(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*services.Schema)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *services.SchemaGenerateRequest) error); ok {
		r1 = returnFunc(ctx, request)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockSchemaGenerateService_Exec_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exec'
type MockSchemaGenerateService_Exec_Call struct {
	*mock.Call
}

// Exec is a helper method to define mock.On call
//   - ctx context.Context
//   - request *services.SchemaGenerateRequest
func (_e *MockSchemaGenerateService_Expecter) Exec(ctx interface{}, request interface{}) *MockSchemaGenerateService_Exec_Call {
	return &MockSchemaGenerateService_Exec_Call{Call: _e.mock.On("Exec", ctx, request)}
}

func (_c *MockSchemaGenerateService_Exec_Call) Run(run func(ctx context.Context, request *services.SchemaGenerateRequest)) *MockSchemaGenerateService_Exec_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *services.SchemaGenerateRequest
		if args[1] != nil {
			arg1 = args[1].(*services.SchemaGenerateRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockSchemaGenerateService_Exec_Call) Return(schema *services.Schema, err error) *MockSchemaGenerateService_Exec_Call {
	_c.Call.Return(schema, err)
	return _c
}

func (_c *MockSchemaGenerateService_Exec_Call) RunAndReturn(run func(ctx context.Context, request *services.SchemaGenerateRequest) (*services.Schema, error)) *MockSchemaGenerateService_Exec_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockSchemaListVersionsService creates a new instance of MockSchemaListVersionsService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockSchemaListVersionsService(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockSchemaListVersionsService {
	mock := &MockSchemaListVersionsService{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockSchemaListVersionsService is an autogenerated mock type for the SchemaListVersionsService type
type MockSchemaListVersionsService struct {
	mock.Mock
}

type MockSchemaListVersionsService_Expecter struct {
	mock *mock.Mock
}

func (_m *MockSchemaListVersionsService) EXPECT() *MockSchemaListVersionsService_Expecter {
	return &MockSchemaListVersionsService_Expecter{mock: &_m.Mock}
}

// Exec provides a mock function for the type MockSchemaListVersionsService
func (_mock *MockSchemaListVersionsService) Exec(ctx context.Context, request *services.SchemaListVersionsRequest) ([]*services.SchemaVersion, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for Exec")
	}

	var r0 []*services.SchemaVersion
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *services.SchemaListVersionsRequest) ([]*services.SchemaVersion, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *services.SchemaListVersionsRequest) []*services.SchemaVersion); ok {
		r0 = returnFunc(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*services.SchemaVersion)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *services.SchemaListVersionsRequest) error); ok {
		r1 = returnFunc(ctx, request)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockSchemaListVersionsService_Exec_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exec'
type MockSchemaListVersionsService_Exec_Call struct {
	*mock.Call
}

// Exec is a helper method to define mock.On call
//   - ctx context.Context
//   - request *services.SchemaListVersionsRequest
func (_e *MockSchemaListVersionsService_Expecter) Exec(ctx interface{}, request interface{}) *MockSchemaListVersionsService_Exec_Call {
	return &MockSchemaListVersionsService_Exec_Call{Call: _e.mock.On("Exec", ctx, request)}
}

func (_c *MockSchemaListVersionsService_Exec_Call) Run(run func(ctx context.Context, request *services.SchemaListVersionsRequest)) *MockSchemaListVersionsService_Exec_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *services.SchemaListVersionsRequest
		if args[1] != nil {
			arg1 = args[1].(*services.SchemaListVersionsRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockSchemaListVersionsService_Exec_Call) Return(schemaVersions []*services.SchemaVersion, err error) *MockSchemaListVersionsService_Exec_Call {
	_c.Call.Return(schemaVersions, err)
	return _c
}

func (_c *MockSchemaListVersionsService_Exec_Call) RunAndReturn(run func(ctx context.Context, request *services.SchemaListVersionsRequest) ([]*services.SchemaVersion, error)) *MockSchemaListVersionsService_Exec_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockSchemaRewriteService creates a new instance of MockSchemaRewriteService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockSchemaRewriteService(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockSchemaRewriteService {
	mock := &MockSchemaRewriteService{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockSchemaRewriteService is an autogenerated mock type for the SchemaRewriteService type
type MockSchemaRewriteService struct {
	mock.Mock
}

type MockSchemaRewriteService_Expecter struct {
	mock *mock.Mock
}

func (_m *MockSchemaRewriteService) EXPECT() *MockSchemaRewriteService_Expecter {
	return &MockSchemaRewriteService_Expecter{mock: &_m.Mock}
}

// Exec provides a mock function for the type MockSchemaRewriteService
func (_mock *MockSchemaRewriteService) Exec(ctx context.Context, request *services.SchemaRewriteRequest) (*services.Schema, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for Exec")
	}

	var r0 *services.Schema
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *services.SchemaRewriteRequest) (*services.Schema, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *services.SchemaRewriteRequest) *services.Schema); ok {
		r0 = returnFunc(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*services.Schema)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *services.SchemaRewriteRequest) error); ok {
		r1 = returnFunc(ctx, request)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockSchemaRewriteService_Exec_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exec'
type MockSchemaRewriteService_Exec_Call struct {
	*mock.Call
}

// Exec is a helper method to define mock.On call
//   - ctx context.Context
//   - request *services.SchemaRewriteRequest
func (_e *MockSchemaRewriteService_Expecter) Exec(ctx interface{}, request interface{}) *MockSchemaRewriteService_Exec_Call {
	return &MockSchemaRewriteService_Exec_Call{Call: _e.mock.On("Exec", ctx, request)}
}

func (_c *MockSchemaRewriteService_Exec_Call) Run(run func(ctx context.Context, request *services.SchemaRewriteRequest)) *MockSchemaRewriteService_Exec_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *services.SchemaRewriteRequest
		if args[1] != nil {
			arg1 = args[1].(*services.SchemaRewriteRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockSchemaRewriteService_Exec_Call) Return(schema *services.Schema, err error) *MockSchemaRewriteService_Exec_Call {
	_c.Call.Return(schema, err)
	return _c
}

func (_c *MockSchemaRewriteService_Exec_Call) RunAndReturn(run func(ctx context.Context, request *services.SchemaRewriteRequest) (*services.Schema, error)) *MockSchemaRewriteService_Exec_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockSchemaSelectService creates a new instance of MockSchemaSelectService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockSchemaSelectService(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockSchemaSelectService {
	mock := &MockSchemaSelectService{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockSchemaSelectService is an autogenerated mock type for the SchemaSelectService type
type MockSchemaSelectService struct {
	mock.Mock
}

type MockSchemaSelectService_Expecter struct {
	mock *mock.Mock
}

func (_m *MockSchemaSelectService) EXPECT() *MockSchemaSelectService_Expecter {
	return &MockSchemaSelectService_Expecter{mock: &_m.Mock}
}

// Exec provides a mock function for the type MockSchemaSelectService
func (_mock *MockSchemaSelectService) Exec(ctx context.Context, request *services.SchemaSelectRequest) (*services.Schema, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for Exec")
	}

	var r0 *services.Schema
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *services.SchemaSelectRequest) (*services.Schema, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *services.SchemaSelectRequest) *services.Schema); ok {
		r0 = returnFunc(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*services.Schema)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *services.SchemaSelectRequest) error); ok {
		r1 = returnFunc(ctx, request)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockSchemaSelectService_Exec_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exec'
type MockSchemaSelectService_Exec_Call struct {
	*mock.Call
}

// Exec is a helper method to define mock.On call
//   - ctx context.Context
//   - request *services.SchemaSelectRequest
func (_e *MockSchemaSelectService_Expecter) Exec(ctx interface{}, request interface{}) *MockSchemaSelectService_Exec_Call {
	return &MockSchemaSelectService_Exec_Call{Call: _e.mock.On("Exec", ctx, request)}
}

func (_c *MockSchemaSelectService_Exec_Call) Run(run func(ctx context.Context, request *services.SchemaSelectRequest)) *MockSchemaSelectService_Exec_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *services.SchemaSelectRequest
		if args[1] != nil {
			arg1 = args[1].(*services.SchemaSelectRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockSchemaSelectService_Exec_Call) Return(schema *services.Schema, err error) *MockSchemaSelectService_Exec_Call {
	_c.Call.Return(schema, err)
	return _c
}

func (_c *MockSchemaSelectService_Exec_Call) RunAndReturn(run func(ctx context.Context, request *services.SchemaSelectRequest) (*services.Schema, error)) *MockSchemaSelectService_Exec_Call {
	_c.Call.Return(run)
	return _c
}
